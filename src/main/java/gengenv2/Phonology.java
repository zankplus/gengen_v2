/** Copyright 2018, 2019 Clayton Cooper
 *	
 *	This file is part of gengen2.
 *
 *	gengen2 is free software: you can redistribute it and/or modify
 *	it under the terms of the GNU General Public License as published by
 *	the Free Software Foundation, either version 3 of the License, or
 *	(at your option) any later version.
 *
 *	gengen2 is distributed in the hope that it will be useful,
 *	but WITHOUT ANY WARRANTY; without even the implied warranty of
 *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *	GNU General Public License for more details.
 *
 *	You should have received a copy of the GNU General Public License
 *	along with gengen2.  If not, see <http://www.gnu.org/licenses/>.
 * 
 */

package gengenv2;

import java.io.OutputStream;
import java.io.PrintStream;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Random;
import java.util.Set;

import org.apache.commons.math3.distribution.LogNormalDistribution;


/**
 * An individual, complete Phonology, or language. Each Phonology contains its own set of sounds (phonemic inventory),
 * rules for assembling those sounds into syllables and words (phonotactics), rules for syllable weight and stress
 * (prosody), and a host of other assorted parameters that govern the shape these features take. All Phonologies
 * share the same system of representing sounds in letters (orthography), which is (mostly) intuitive and (mostly)
 * unambiguous. A Phonology uses these features to generate new names that are sound linguistically similar to each
 * other,  but distinct from those generated by other Phonologies.
 * 
 * @author	Clayton Cooper
 * @version	1.0
 * @since	1.0
 */
public class Phonology
{
	protected Random rng;
	private String name;
	private long seed;
	private Phonology thisPhonology;
	
	/*
	 * Auxiliary systems
	 * 
	 * These are other special systems used by the Phonology to aid in name-making, defined in their own classes.
	 * nameAssembly creates words using phonology's rules for syllable structure. stressRules represents the 
	 * Phonology's rules for stress and rhythm, and is used to assign stress to words NameAssembly has made.
	 */
	NameAssembly assembly;
	StressRules stressRules;
	SuffixLibrary suffixes;
	
	/* Prominence values
	 * 
	 *  Through repeated use in variable names, "prominence" has become, for me, something of a technical term, denoting
	 *  a raw measure of how common a phonological unit (a phoneme, a phonetic property, a syllable segment) is.
	 *  The value of a prominence variable doesn't have any meaning on its own, but often the prominences of every
	 *  member in a class of segments are summed to determine the probability of that segment appearing.
	 *  
	 *  The first three arrays of prominences below are a little different: they are never used directly, but are rather 
	 *  combined to determine prominence values for segments. They represent the prevalence of different properties in 
	 *  the Phonology's phonemic inventory.
	 *  
	 *  The "lead" and "follow" prominences represent a phoneme's tendency to precede or follow other sounds within
	 *  a consonant cluster, diphthong, or interlude, and are used to determine how commonplace each such cluster is.
	 */
	
	boolean[] consonantPropertiesRepresented;
	boolean[] vowelPropertiesRepresented;
	
	PhoneticRatings baseConsonantRatings;	// Prominence of each consonantal phonetic property in the Phonology, as applied to 
											// syllable onsets. This is the the basic value from which other consonantal prominences
											// are derived by disturbance.
	PhoneticRatings baseCodaRatings;		// Prominence of each consonantal property, as applied to syllable codas
	PhoneticRatings wordInitialRatings;
	PhoneticRatings terminalCodaRatings;
	
	PhoneticRatings baseVowelRatings;			// Prominence of each vocalic phonetic property
	PhoneticRatings	initialNucleusRatings;		// Prominence of 
	PhoneticRatings	terminalNucleusRatings;
	PhoneticRatings rootNucleusRatings;
	
	PhoneticRatings onsetClusterLeadRatings;
	PhoneticRatings onsetClusterFollowRatings;
	PhoneticRatings diphthongLeadRatings;
	PhoneticRatings diphthongFollowRatings;
	PhoneticRatings codaClusterLeadRatings;
	PhoneticRatings codaClusterFollowRatings;
	PhoneticRatings hiatusLeadRatings;
	PhoneticRatings hiatusFollowRatings;
	PhoneticRatings interludeLeadRatings;
	PhoneticRatings interludeFollowRatings;
	
	/*
	 * Phoneme inventories
	 * 	
	 * Arrays containing of all the phonemes (potentially) in the Phonology. These are sorted into consonant and
	 * vowel inventories. Note that a phoneme appearing in one of these inventories may still be absent from the
	 * language in practice if its prominence is 0 in every context.
	 */
	ConsonantPhoneme[] consonantInventory;	// List of CONSONANTS represented in this Phonology
	VowelPhoneme[] vowelInventory;		// List of VOWELS represented in this Phonology
	
	/*
	 * Syllable segment inventories
	 * 
	 * Lists of arrays enumerating every onset, nucleus, and coda available in the language. Each array contains
	 * all possible syllable segments of a certain length according to the array's index: the 0th array contains
	 * single phonemes ('simple' segments), the 1th array contains complex segments formed of 2 phonemes, the
	 * 2nd of 3, and so forth. Syllable segments with non-positive prominence are pruned can never appear and so
	 * are pruned from these lists.
	 */
	protected ConstituentLibrary medialOnsets;
	protected ConstituentLibrary initialOnsets;
	protected ConstituentLibrary medialNuclei;
	protected ConstituentLibrary initialNuclei;
	protected ConstituentLibrary terminalNuclei;
	protected ConstituentLibrary rootNuclei;
	protected ConstituentLibrary medialCodas;	
	protected ConstituentLibrary terminalCodas;
	
	/*
	 * Syllable segment length limits
	 * 
	 *  Determine the maximum length a consonant cluster or diphthong may take. These values are generated in
	 *  makeBasicSyllableStructure() but may be reduced during generation if no clusters of sufficient length
	 *  are present in that language. This keeps methods from trying to pick a syllable segment from an empty
	 *  list if, say, a Phonology technically allows onset clusters of length 3 but doesn't actually have any. 
	 */
	private int maxOnsetLength;
	private int maxNucleusLength;
	private int maxCodaLength;
	
	/*
	 * Coda prominence variables
	 * 
	 * codaProminenceOffset is a flat value subtracted from every coda prominence value to manage the richness
	 * of the coda inventory. codaDisturbance governs how greatly the base prominences are disturbed to produce
	 * the coda prominence values, AS A PERCENTAGE of the prominenceStdev. At 0, coda values are undisturbed 
	 * compared to the base values; at 1, they have essentially been rerolled from scratch.
	 */
	private double codaRatingOffset;
	private double codaDisturbance;
	
	/*
	 * General cluster offsets
	 * 
	 * Offset values are added to or subtracted from the prominence of consonant clusters or diphthongs to
	 * manage the diversity of such features in a Phonology. 
	 */
	private double onsetClusterOffset;
	private double diphthongOffset;
	private double codaClusterOffset;
	private double hiatusOffset;
	private double interludeOffset;

	/*
	 * Specific cluster offsets
	 * 
	 * These values are added to or subtracted from particular cluster prominences in specific circumstances to
	 * help restrict their prominence to (the author's personal sense of) a more natural pattern.
	 */
	double onsetNgOffset;			// reduces the chance of a onset 'ng'
	double onsetTlDlOffset; 		// reduces the chances of an onset 'tl' or 'dl'
	double codaGlottalStopOffset;	// reduces the chances of a coda glottal stop (')
	double nasalDissonanceOffset;	// reduces the prevalence of coda nasal-plosive clusters that disagree in articulation
	double unequalVoicingOffset;	// reduces the prevalence of interludes that disagree in voicing
	
	/*
	 * Phonotactic properties
	 * 
	 * These values are used in the determining where in a syllable certain sounds may appear, which is the task
	 * of the various make____() methods. the ___CategoriesRepresented arrays track which phonetic categories
	 * are present in a language (this can't be done just by consulting their prominences as categories with 
	 * negative prominence may still be present), while the valid___Transitions arrays dictate the phonotactic
	 * categories of which different phonemes might follow each other within clusters.
	 */
	private boolean[] consonantCategoriesRepresented;
	private boolean[] vowelCategoriesRepresented;
	
	private boolean[][] validOnsetTransitions;
	private boolean[][] validNucleusTransitions;
	private boolean[][] validCodaTransitions;

	/*
	 * Base occurrence chances
	 * 
	 * These represent the base chances of various features of syllables occurring, before scaling by the number
	 * of entries available to that class of features. These are used in the Flowchart class to determine the
	 * probability of transitioning between nodes. 
	 * 
	 * Cluster chances represent the chance of a marginally more complex syllable segment occurring. In places
	 * where either a simple or complex segment may occur, these represent the chance of a cluster appearing at
	 * all (as usual, before scaling). Within onset/coda clusters, these affect the chance of a more complex
	 * cluster appearing, and so are factored into the calculation of the ___ClusterLengthProbabilities and 
	 * simple___Probability variables in the setClusterChances() method.
	 */
	protected double baseOnsetClusterChance;
	protected double baseCodaClusterChance;
	protected double baseDiphthongChance;
	
	protected double baseEmptyInitialOnsetChance;
	protected double baseMedialOnsetChance;
	protected double baseMedialCodaChance;
	protected double baseTerminalCodaChance;
	protected double baseSuffixOnsetChance;
	

	/*
	 * Generator properties
	 * 
	 * These static variables are properties of the generate itself and are used to determine the values of
	 * different features within a language that have a random component to them. Most of them represent the
	 * mean and standard deviation values for Gaussian random numbers.
	 */
	
	// Prominence means/stdevs
	static double basicProminenceStdev				= 0.60;
	static double basicProminenceMean				= 0.85;
	static double basicCodaStdev					= 0.60;
	static double basicCodaMean						= 0.90;
	static double vowelProminenceStdev 				= 0.50;
	static double vowelProminenceMean				= 1.00;
	static double wordInitialStdev					= 0.25;
	static double wordInitialMean					= 0.25;
	static double emptyInitialOnsetProminenceMean   = 0.3;
	static double emptyInitialOnsetProminenceStdev  = 0.15;
	static double onsetClusterProminenceMean	 	= 0.1;
	static double onsetClusterProminenceStdev 		= 0.05;
	static double clusterLeadStdev    				= 0.50;
	static double clusterLeadMean					= 1.00;
	static double clusterFollowStdev  				= 0.50;
	static double clusterFollowMean					= 1.00;
	static double diphthongLeadStdev  				= 0.50;
	static double diphthongLeadMean					= 1.00;
	static double diphthongFollowStdev 				= 0.50;
	static double diphthongFollowMean				= 1.00;
	static double hiatusLeadStdev  					= 0.50;
	static double hiatusLeadMean  					= 1.00;
	static double hiatusFollowStdev					= 0.50;
	static double hiatusFollowMean					= 1.00;

	// Bounding values
	static double minimumOnsetClusterProminence		= 0.01; 
	static double minimumNucleusClusterProminence	= 0.01;
	static double minimumCodaClusterProminence		= 0.01;
	
	// Offset means/stdevs
	static double codaOffsetMean					= 0.4;
	static double codaOffsetStdev					= 0.4;
	static double onsetNgOffsetMean					= 2;
	static double onsetNgOffsetStdev				= 1;
	static double onsetTlDlOffsetMean				= 1;
	static double onsetTlDlOffsetStdev				= 0.5;
	static double codaGlottalStopOffsetMean			= 5;
	static double codaGlottalStopOffsetStdev		= 1;
	static double nasalDissonanceOffsetMean			= 2;
	static double nasalDissonanceOffsetStdev		= 1;
	static double unequalVoicingOffsetMean			= 1.25;
	static double unequalVoicingOffsetStdev			= 0.5;
	static double hiatusOffsetStdev					= 0.15;
	static double interludeOffsetStdev				= 0.15;
	
	// Base occurence chance means/stdevs 
	static double strongHeavyRimeChanceMean			= 0.8;
	static double strongHeavyRimeChanceStdev		= 0.2;
	static double weakHeavyRimeChanceMean			= 0.3;
	static double weakHeavyRimeChanceStdev			= 0.15;
	static double baseCodaChanceMean				= -0.5;
	static double baseCodaChanceStdev				= 0.5;
	static double codaLocationBalanceMean			= 0.4;
	static double codaLocationBalanceStdev			= 0.33;
	static double baseOnsetChanceMean				= 0;
	static double baseOnsetChanceStdev				= 0.1;
	static double baseOnsetChanceOffset				= 0.8;
	
	// Name assembly properties
	static double heavyRimeSuppressionFactor		= 1.5;
	
	/*
	 * Statistical data
	 * 
	 * Assorted information about the prevalence of different syllabic features in the current Phonology.
	 * The items named in the final ints are stored in the respective indices in counts[].
	 */
	public int[] counts = new int[11];

	// Indices of counts 
	static final int SIMPLE_ONSETS				=  0;
	static final int COMPLEX_ONSETS				=  1;
	static final int SIMPLE_NUCLEI				=  2;
	static final int COMPLEX_NUCLEI				=  3;
	static final int SIMPLE_CODAS				=  4;
	static final int COMPLEX_CODAS				=  5;
	static final int SIMPLE_NUCLEI_WITH_HIATUS	=  6;
	static final int COMPLEX_NUCLEI_WITH_HIATUS	=  7;
	static final int COMPOUND_INTERLUDES		=  8;
	static final int LIGHT_RIMES				=  9;
	static final int HEAVY_RIMES				= 10;
	
	/**
	 * Sets the rng to a specified seed before calling constructPhonology to set up the Phonology.
	 * @param	seed	The seed to be used for the random number generator
	 * @since	1.0
	 */
	public Phonology(long seed)
	{
		rng = new Random(seed);
		this.seed = seed;
		thisPhonology = this;
		
		// Commence generation
		constructPhonology();
	}

	/**
	 * Sets the rng to a random seed before calling constructPhonology to set up the Phonology proper.
	 * @since	1.0
	 */
	public Phonology()
	{
		this(new Random().nextLong());
	}
	
	/**
	 * The main process by which a Phonology is set up. This creates a complete Phonology by invoking a series of methods
	 * each of which generates some part of the Phonology. The order of operations is important, as some methods depend
	 * on information generated by previous methods, or delete information that other methods use.
	 * @since	1.0
	 */
	private void constructPhonology()
	{
		System.out.println("Phonology Seed: " + seed);
		
		// Commence construction
		makeBasicSyllableStructure();
		determineProminence();
		selectSegments();
		
		// Populate inventories
		makeOnsets();
		makeNuclei();
		makeHiatus();
		
		if (maxCodaLength > 0)
		{
			makeCodas();
		}
		
		// Set base chances for use in the flowchart
		setBaseChances();		
		
		// Create flowchart
		assembly = new SimpleAssembly(this);
		
		makeSuffixes();
		
		// Create stress rules
		stressRules = new StressRules();
	}
	
	/**
	 * This method determines the maximum length for each syllable segment type: onset, nucleus, and coda. For each of
	 * these it also initializes the corresponding arrays in preparation to store all the syllable segments of the
	 * appropriate length, and also determines the base cluster/diphthong chances and offsets. 
	 * @since	1.0
	 */
	private void makeBasicSyllableStructure()
	{
		int roll;
		
		// Determine max length for each syllable segment type.
		roll = rng.nextInt(12);
		if (roll < 3)			
			maxOnsetLength = 1;	// 3/12
		else if (roll < 9)
			maxOnsetLength = 2;	// 6/12
		else if (roll < 11)
			maxOnsetLength = 3;	// 2/12
		else
			maxOnsetLength = 4;	// 1/12
		
		roll = rng.nextInt(4);
		if (roll < 1)
			maxNucleusLength = 1;
		else
			maxNucleusLength = 2;

		roll = rng.nextInt(8);
		if (roll < 1)
			maxCodaLength = maxOnsetLength + 1;	// 1/8
		else if (roll < 4)
			maxCodaLength = maxOnsetLength;		// 3/8
		else if (roll < 7)
			maxCodaLength = maxOnsetLength - 1;	// 3/8
		else
			maxCodaLength = maxOnsetLength - 2;	// 1/8
		maxCodaLength = Math.max(maxCodaLength, 0);
		
		// Determine cluster offsets
		if (maxOnsetLength > 0)
		{
			baseOnsetClusterChance = Math.max(rng.nextGaussian() * onsetClusterProminenceStdev + onsetClusterProminenceMean,
											  minimumOnsetClusterProminence);
			onsetClusterOffset = rng.nextGaussian() * 0.25 + 0.5;
		}

		if (maxNucleusLength > 1)
		{
			baseDiphthongChance = Math.max(rng.nextGaussian() * 0.05 + 0.15, minimumNucleusClusterProminence);
			diphthongOffset = rng.nextGaussian() * 0.25 + 0.5;
		}
		
		if (maxCodaLength > 0)
		{
			baseCodaClusterChance = Math.max(rng.nextGaussian() * 0.1 + 0.25, minimumCodaClusterProminence);
			codaClusterOffset = rng.nextGaussian() * 0.25 + 0.5;
		}
	}

	/**
	 * Determine which phonetic Properties will be present in this language, how prominent they will be,
	 * and in what contexts. A Phoneme can be said to possess its own prominence rating equal to the sum of
	 * its Properties' prominence ratings' means. These ratings are used to determine the probability of
	 * its child syllable Constituents appearing in different contexts. 
	 * 
	 * Related clusterLeadProminence and clusterFollowProminence help determine how frequently a consonant will
	 * appear in a cluster preceeding or following (respectively) other phonemes.
	 * @since	1.0
	 */ 
	private void determineProminence()
	{
		// Determine which properties are represented
		consonantPropertiesRepresented = new boolean[ConsonantProperty.values().length];
		vowelPropertiesRepresented = new boolean[VowelProperty.values().length];
		
		for (int i = 0; i < ConsonantProperty.values().length; i++)
			if (rng.nextDouble() < ConsonantProperty.values()[i].getProbability())
				consonantPropertiesRepresented[i] = true;
		
		for (int i = 0; i < VowelProperty.values().length; i++)
			if (rng.nextDouble() < VowelProperty.values()[i].getProbability())
				vowelPropertiesRepresented[i] = true;
		
		// Set onset prominence ratings for consonant properties
		
		// Medial onsets
		baseConsonantRatings = new PhoneticRatings(true, basicProminenceStdev, basicProminenceMean);
		
		// Initial onsets
		wordInitialRatings = new PhoneticRatings(baseConsonantRatings);
		wordInitialRatings.disturb(0.5);
		
		// Medial nuclei
		baseVowelRatings = new PhoneticRatings(false, vowelProminenceStdev, vowelProminenceMean);
 
		initialNucleusRatings = new PhoneticRatings(baseVowelRatings);
		initialNucleusRatings.disturb(0.5);
		initialNucleusRatings.offset(-0.10);
		
		terminalNucleusRatings = new PhoneticRatings(baseVowelRatings);
		terminalNucleusRatings.disturb(0.5);
		terminalNucleusRatings.offset(-0.25);
		
		rootNucleusRatings = new PhoneticRatings(baseVowelRatings);
		rootNucleusRatings.disturb(0.5);
		rootNucleusRatings.offset(-0.25);
		

		
		/*
		 * Set coda prominence values for consonant properties. 
		 * Coda prominence values are generated by "disturbing" base prominence values, that is, by adding a 
		 * randomly generated Gaussian term, so they are influenced by onset values but not beholden
		 * to them. The magnitude of the Gaussian term is determined by codaDisturbance, representing the
		 * proportion of prominenceStdev by which to scale the deviation.
		 */
		if (maxCodaLength > 0)
		{
			// Medial codas
			baseCodaRatings = new PhoneticRatings(true, basicCodaStdev, basicCodaMean);
			
			// Coda disturbance is the square of a uniformly distributed random number between 0 and 1
			codaDisturbance = Math.pow(rng.nextDouble(), 2);
			
			codaRatingOffset = rng.nextGaussian() * codaOffsetStdev + codaOffsetMean;
			codaRatingOffset = -Math.max(0, codaRatingOffset);
			
			baseCodaRatings.disturb(basicProminenceStdev * codaDisturbance);
			baseCodaRatings.offset(codaRatingOffset);
			
			terminalCodaRatings = new PhoneticRatings(baseCodaRatings);
			terminalCodaRatings.disturb(0.5);
		}
		
		// Set onset cluster lead/follow prominences
		if (maxOnsetLength > 1)
		{
			onsetClusterLeadRatings   = new PhoneticRatings(true, clusterLeadStdev, clusterLeadMean);
			onsetClusterFollowRatings = new PhoneticRatings(true, clusterFollowStdev, clusterFollowMean);
		}

		// Set diphthong (nucleus cluster) lead/follow prominences
		if (maxNucleusLength > 1)
		{
			diphthongLeadRatings   = new PhoneticRatings(false, diphthongLeadStdev, diphthongLeadMean);
			diphthongFollowRatings = new PhoneticRatings(false, diphthongFollowStdev, diphthongFollowMean);
		}
		
		// Set coda lead/follow prominences
		if (maxCodaLength > 1)
		{
			codaClusterLeadRatings   = new PhoneticRatings(true, clusterLeadStdev, clusterLeadMean);
			codaClusterFollowRatings = new PhoneticRatings(true, clusterFollowStdev, clusterFollowMean);
		}

		// Set hiatus ratings
		hiatusLeadRatings =   new PhoneticRatings(true, hiatusLeadStdev, hiatusLeadMean);
		hiatusFollowRatings = new PhoneticRatings(true, hiatusFollowStdev, hiatusFollowMean);
		
		// Set interlude lead/follow prominences
		interludeLeadRatings =   new PhoneticRatings(true, clusterLeadStdev, clusterLeadMean);
		interludeFollowRatings = new PhoneticRatings(true, clusterFollowStdev, clusterFollowMean);
		
		// Set miscellaneous phonotactic offsets
		onsetNgOffset   	  = Math.max(rng.nextGaussian() * onsetNgOffsetStdev + onsetNgOffsetMean, 0);
		onsetTlDlOffset 	  = Math.max(rng.nextGaussian() * onsetTlDlOffsetStdev + onsetTlDlOffsetMean, 0);
		codaGlottalStopOffset = Math.max(rng.nextGaussian() * codaGlottalStopOffsetStdev + codaGlottalStopOffsetMean, 0);
		nasalDissonanceOffset = Math.max(rng.nextGaussian() * nasalDissonanceOffsetStdev + nasalDissonanceOffsetMean, 0);
		unequalVoicingOffset  = Math.max(rng.nextGaussian() * unequalVoicingOffsetStdev + unequalVoicingOffsetMean, 0);
	}
	
	/**
	 * Decide which segments will be present in the language. Any phoneme all of whose constituent phonetic categories
	 * are present (i.e., have positive prominence) should be added. The same procedure is performed twice: once for
	 * consonants and one for vowels.
	 * @since	1.0
	 */
	private void selectSegments()
	{
		ArrayList<Phoneme> inv = new ArrayList<Phoneme>();
		
		// Make easy reference to consonant segment array
		Consonant[] consonants = Consonant.segments;
		ArrayList<Consonant> defective = new ArrayList<Consonant>();
		
		// Populate consonant inventory
		for (int i = 0; i < consonants.length; i++)
		{
			// Resolve to add the segment to the inventory by default.
			// If any of the segment's properties has 0 prominence (i.e., is absent from the language), immediately
			// decide not to add the segment.
			boolean add = true;
			
			for (int j = 0; j < consonants[i].properties.length; j++) 
				if (baseConsonantRatings.getRating(((ConsonantProperty) consonants[i].properties[j]).ordinal()) == 0)
				{
					add = false;
					j = consonants[i].properties.length;
				}
			
			if (add)
			{
				if (rng.nextDouble() > consonants[i].defectiveChance)
					inv.add(new ConsonantPhoneme(consonants[i]));
				else
					defective.add(consonants[i]);
			}		
		}
		
		consonantInventory = inv.toArray(new ConsonantPhoneme[0]);
		
		// If this language has no consonants, add 'P' to the inventory
		if (consonantInventory.length == 0)
		{
			for (int i = 0; i < Consonant.segments[0].properties.length; i++)
				baseConsonantRatings.setRating(Consonant.segments[0].properties[i].ordinal(), 1);
			
			consonantInventory = new ConsonantPhoneme[] { new ConsonantPhoneme(Consonant.segments[0]) };
		}
		
		// Mark phonotactic transition categories represented in this language's inventory
		consonantCategoriesRepresented = new boolean[Phonotactics.consonantCategories.size()];
		for (Phoneme p : inv)
			consonantCategoriesRepresented[p.segment.transitionCategory] = true;
		
		// Make easy reference to vowel segment array
		Vowel[] vowels = Vowel.segments;
		
		inv = new ArrayList<Phoneme>();
		
		// Populate vowel inventory in the same fashion as the consonant array
		for (int i = 0; i < vowels.length; i++)
		{
			boolean add = true;
			
			for (int j = 0; j < vowels[i].properties.length; j++)
				if (baseVowelRatings.getRating(((VowelProperty) vowels[i].properties[j]).ordinal()) == 0)
				{
					add = false;
					j = vowels[i].properties.length;
				}
			
			if (add)
				inv.add(new VowelPhoneme(vowels[i]));
		}
		
		vowelInventory = inv.toArray(new VowelPhoneme[inv.size()]);
		
		// If this language has no vowels, add 'A' to the inventory
		if (vowelInventory.length == 0)
		{
			baseVowelRatings.setRating(VowelProperty.OPEN.ordinal(), 1);
			vowelInventory = new VowelPhoneme[] { new VowelPhoneme(Vowel.segments[1]) };
		}
		
		// Mark phonotactic transition categories represented in this language's inventory
		vowelCategoriesRepresented = new boolean[Phonotactics.vowelCategories.size()];
		for (Phoneme p : inv)
			vowelCategoriesRepresented[p.segment.transitionCategory] = true;
	}
	
	/**
	 * First, this method determines which transitions are possible between different phonotactic categories,
	 * and therefore which Phoneme pairs might occur as a consonant cluster in this Phonology's onsets.
	 * Having decided this, the method invokes findAllOnsets() to populate the onset list.
	 * @since	1.0
	 */
	private void makeOnsets()
	{
		// transProb contains every combination of 2 phonotactic categories
		int[][] transProb = Phonotactics.onsetTransitions;
		validOnsetTransitions = new boolean[transProb.length][transProb[0].length];
		
		// Roll lead and follow probabilities for each phonotactic category
		double[] leadProbability = new double[transProb.length], followProbability = new double[transProb[0].length];
		for (int i = 0; i < leadProbability.length; i++)
			leadProbability[i] = rng.nextDouble();
		for (int i = 0; i < followProbability.length; i++)
			followProbability[i] = rng.nextDouble();
		
		
		/* Determine which transitions are possible between phonotactic categories.
		 * Every possible transition between categories has a chance of occurring, but those chances
		 * are not wholly independent from each other. Instead of rolling an independent random variable
		 * for each combination, we instead roll two for each category - one to indicate the chance of it
		 * leading in a cluster, the other the chance of following. These are both uniformly distributed
		 * random variables between 0 and 1. The roll for the inclusion of a given cluster is the product
		 * of the the first Phoneme's leadProbability and the second's followProbability. The cdf for the
		 * the product of these two random variables is f(z) = z - z * log z.
		 */
		for (int i = 0; i < transProb.length; i++)
			if (consonantCategoriesRepresented[i])
				for (int j = 0; j < transProb[0].length; j++)
					if (consonantCategoriesRepresented[j])
					{
						// Chance of representation ~= f(.4 x 15^(commonness - 3))
						// 3 -> .559, 2 -> .069, 1 -> .007
						double p = 0.4 * Math.pow(15, transProb[i][j] - 3);
						
						if (leadProbability[i] * followProbability[j] < p)
							validOnsetTransitions[i][j] = true; 
					}
	
		// Add lists of constituents to library object
		medialOnsets = new ConstituentLibrary(this, maxOnsetLength, ConstituentType.ONSET, 
												ConstituentLocation.MEDIAL);
		
		generateOnsets(medialOnsets);
		
		medialOnsets.removeUnusedMembers();
		medialOnsets.normalizeAll();
		medialOnsets.sortAll();
		medialOnsets.setLengthProbabilities(baseOnsetClusterChance);
		
		
		initialOnsets = new ConstituentLibrary(this, maxOnsetLength, ConstituentType.ONSET, 
												ConstituentLocation.INITIAL);
		generateOnsets(initialOnsets);
		initialOnsets.removeUnusedMembers();
//		initialOnsets.exaggerate(2);
		initialOnsets.normalizeAll();
		initialOnsets.sortAll();
		initialOnsets.setLengthProbabilities(baseOnsetClusterChance);
	}
	
	/**
	 * First, this method determines which transitions are possible between different phonotactic categories,
	 * and therefore which Phoneme pairs might occur as diphthongs in this Phonology. Having decided this, 
	 * the method invokes findAllNuclei() to populate the nucleus list.
	 * 
	 * The math motivating the selection of phonotactic category transitions is explained in makeOnsets() and
	 * will not be restated here.
	 * 
	 * @since	1.0
	 */
	private void makeNuclei()
	{
		int[][] transProb = Phonotactics.nucleusTransitions;
		validNucleusTransitions = new boolean[transProb.length][transProb[0].length];
		
		// Roll lead and follow probabilities for each phonotactic category
		double[] leadProbability = new double[transProb.length], followProbability = new double[transProb[0].length];
		for (int i = 0; i < leadProbability.length; i++)
			leadProbability[i] = rng.nextDouble();
		for (int i = 0; i < followProbability.length; i++)
			followProbability[i] = rng.nextDouble();
		
		// Determine which transitions are possible between phonotactic categories
		for (int i = 0; i < transProb.length; i++)
		{
			if (vowelCategoriesRepresented[i])
				for (int j = 0; j < transProb[0].length; j++)
					if (vowelCategoriesRepresented[j] && transProb[i][j] > 0)
					{
						// Chance of representation ~= f(.4 x 15^(commonness - 3))
						// 3 -> .559, 2 -> .069, 1 -> .007
						double p = 0.4 * Math.pow(15, transProb[i][j] - 3);
						
						if (leadProbability[i] * followProbability[j] < p)
							validNucleusTransitions[i][j] = true; 
					}
		}
		
		// Populate medial nucleus library
		medialNuclei = new ConstituentLibrary(this, maxNucleusLength, ConstituentType.NUCLEUS,
												ConstituentLocation.MEDIAL);
		generateNuclei(medialNuclei);
		medialNuclei.removeUnusedMembers();
		medialNuclei.normalizeAll();
		medialNuclei.sortAll();
		medialNuclei.setLengthProbabilities(baseDiphthongChance);
		
		// Populate initial nucleus library
		initialNuclei = new ConstituentLibrary(this, maxNucleusLength, ConstituentType.NUCLEUS,
												ConstituentLocation.INITIAL);
		generateNuclei(initialNuclei);
		initialNuclei.removeUnusedMembers();
		medialNuclei.exaggerate(2);
		initialNuclei.normalizeAll();
		initialNuclei.sortAll();
		initialNuclei.setLengthProbabilities(baseDiphthongChance);
		
		// Populate initial nucleus library
		terminalNuclei = new ConstituentLibrary(this, maxNucleusLength, ConstituentType.NUCLEUS,
												ConstituentLocation.TERMINAL);
		generateNuclei(terminalNuclei);
		terminalNuclei.removeUnusedMembers();
		terminalNuclei.exaggerate(2);
		terminalNuclei.normalizeAll();
		terminalNuclei.sortAll();
		terminalNuclei.setLengthProbabilities(baseDiphthongChance);

		// Populate initial nucleus library
		rootNuclei = new ConstituentLibrary(this, maxNucleusLength, ConstituentType.NUCLEUS,
											ConstituentLocation.ROOT);
		generateNuclei(rootNuclei);
		rootNuclei.removeUnusedMembers();
		rootNuclei.normalizeAll();
		rootNuclei.sortAll();
		rootNuclei.setLengthProbabilities(baseDiphthongChance);
	}

	/**
	 * First, this method determines which transitions are possible between different phonotactic categories,
	 * and therefore which Phoneme pairs might occur as consonant clusters in this Phonology's codas. Having
	 * decided this, the method invokes findAllCodas() to populate the nucleus list.
	 * 
	 * The math motivating the selection of phonotactic category transitions is explained in makeOnsets() and
	 * will not be restated here.
	 * 
	 * @since	1.0
	 */
	private void makeCodas()
	{
		int[][] transProb = Phonotactics.codaTransitions;
		validCodaTransitions = new boolean[transProb.length][transProb[0].length];
		
		// Roll lead and follow probabilities for each phonotactic category
		double[] leadProbability = new double[transProb.length], followProbability = new double[transProb[0].length];
		for (int i = 0; i < leadProbability.length; i++)
			leadProbability[i] = rng.nextDouble();
		for (int i = 0; i < followProbability.length; i++)
			followProbability[i] = rng.nextDouble();

		// Determine which transitions are possible between phonotactic categories
		for (int i = 0; i < transProb.length; i++)
			if (consonantCategoriesRepresented[i])
				for (int j = 0; j < transProb[0].length; j++)
					if (consonantCategoriesRepresented[j] && transProb[i][j] > 0)
					{
						// Chance of representation ~= f(.4 x 15^(commonness - 3))
						// 3 -> .559, 2 -> .069, 1 -> .007
						double p = 0.4 * Math.pow(15, transProb[i][j] - 3);
						
						if (leadProbability[i] * followProbability[j] < p)
							validCodaTransitions[i][j] = true; 
					}
	
		// Initialize coda library
		medialCodas = new ConstituentLibrary(this, maxCodaLength, ConstituentType.CODA,
												ConstituentLocation.MEDIAL);
		
		// Populate coda list
		generateCodas(medialCodas);

		// Remove unused codas
		medialCodas.removeUnusedMembers();
		
		// Note that unlike makeOnsets and makeNuclei, in makeCodas We delay the normalization of coda values until after
		// makeInterludes, as that method makes use of codas (in particular, that may be cut from the master list.
		
		if (medialCodas.maxLength() > 0)
			makeInterludes();
		
		terminalCodas = new ConstituentLibrary(this, maxCodaLength, ConstituentType.CODA, 
												ConstituentLocation.TERMINAL);
		generateCodas(terminalCodas);
		terminalCodas.removeUnusedMembers();
		terminalCodas.exaggerate(2);
		terminalCodas.normalizeAll();
		terminalCodas.sortAll();
		terminalCodas.setLengthProbabilities(baseDiphthongChance);
	}
	
	/**
	 * This method decides what vowel-vowel transitions are allowed in the case of an empty interlude. The process
	 * is analogous to that used by the makeOnsets/Nuclei/Codas methods, except that transitions occur directly
	 * between vowels instead of phonotactic categories, if a transition is found, it is immediately added to the
	 * leading vowel's interlude list.
	 * 
	 * @since	1.0
	 */
	private void makeHiatus()
	{
		// Create follower lists for all vowels in inventory
		for (VowelPhoneme vp : vowelInventory)
		{
			vp.followers = new ConstituentLibrary(this, medialNuclei.maxLength(), ConstituentType.NUCLEUS,
													ConstituentLocation.MEDIAL);
			vp.terminalFollowers = new ConstituentLibrary(this, terminalNuclei.maxLength(),
															ConstituentType.NUCLEUS, ConstituentLocation.TERMINAL);
			vp.rootFollowers = new ConstituentLibrary(this, rootNuclei.maxLength(), ConstituentType.NUCLEUS,
														ConstituentLocation.ROOT);
		}
		
		hiatusOffset = rng.nextGaussian() * hiatusOffsetStdev;
		
		int[][] transProb = Phonotactics.hiatusTransitions;

		// Roll lead and follow probabilities.
		// -1 to count ignores the 'lengthener' segment
		double[] leadProbabilities = new double[Vowel.count - 1], followProbabilities = new double[Vowel.count - 1];
		for (int i = 0; i < leadProbabilities.length; i++)
		{
			leadProbabilities[i] = rng.nextDouble();
			followProbabilities[i] = rng.nextDouble();
		}
		
		// Medial hiatus
		for (VowelPhoneme v1 : vowelInventory)
		{
			makeHiatusForVowel(v1, medialNuclei, leadProbabilities, followProbabilities);
			makeHiatusForVowel(v1, terminalNuclei, leadProbabilities, followProbabilities);
			makeHiatusForVowel(v1, rootNuclei, leadProbabilities, followProbabilities);
			
			// Normalize probabilities and sort the current vowel's interludes according to them
			v1.rootFollowers.normalizeAll();
			v1.rootFollowers.sortAll();
			v1.rootFollowers.setLengthProbabilities(baseDiphthongChance);
			
			v1.followers.normalizeAll();
			v1.followers.sortAll();
			v1.followers.setLengthProbabilities(baseDiphthongChance);
			
			v1.terminalFollowers.normalizeAll();
			v1.terminalFollowers.sortAll();
			v1.terminalFollowers.setLengthProbabilities(baseDiphthongChance);
		}
	}
	
	private void makeHiatusForVowel(VowelPhoneme v1, ConstituentLibrary lib, double[] leadProbabilities,
										double[] followProbabilities)
	{
		for (int j = 0; j < lib.countMembersOfLength(1); j++)
		{
			Phoneme v2 = lib.getMembersOfLength(1).get(j).content[0];
			if (!v1.segment.expression.equals(":"))
			{
				// Chance of representation ~= f(.3 x 4^(commonness - 3))
				// 3 -> .446, 2 -> .155, 1 -> .050
				double probability = 0.3 * Math.pow(4, Phonotactics.hiatusTransitions[v1.segment.id][v2.segment.id]
													- 3) + hiatusOffset;
				if (leadProbabilities[v1.segment.id] * followProbabilities[v2.segment.id] < probability)
				{
					v1.addInterlude(lib.getMembersOfLength(1).get(j), lib.getLocation());
				}
			}
		}
	}
	
	/**
	 * This method determines which onsets may follow a coda. Again, the process is based on that of
	 * makeOnsets/Nuclei/Codas; though like these method it considers transitions between phonotactic
	 * categories, it operates on individual Phonemes and adds connecting onsets directly to the coda's
	 * interlude list.  
	 * 
	 * @since	1.0
	 */
	private void makeInterludes()
	{
		// Create follower lists for all consonants in inventory
		for (Phoneme phoneme : consonantInventory)
		{
			phoneme.followers = new ConstituentLibrary(this, medialOnsets.maxLength(), ConstituentType.ONSET,
														ConstituentLocation.MEDIAL);
		}
		
		interludeOffset = rng.nextGaussian() * interludeOffsetStdev;
		
		int[][] transProb = Phonotactics.interludeTransitions;
		
		// Roll lead and follow probabilities for each phonotactic category
		double[] leadProbability   = new double[transProb.length],
				 followProbability = new double[transProb[0].length];
		for (int i = 0; i < leadProbability.length; i++)
			leadProbability[i] = rng.nextDouble();
		for (int i = 0; i < followProbability.length; i++)
			followProbability[i] = rng.nextDouble();
		
		// Generate lists of interlude transitions for phonemes
		for (int i = 0; i < medialCodas.countMembersOfLength(1); i++)
		{
			Phoneme p1 = medialCodas.getMembersOfLength(1).get(i).content[0];
			for (int j = 0; j < medialOnsets.getMembersOfLength(1).size(); j++)
			{
				Phoneme p2 = medialOnsets.getMembersOfLength(1).get(j).content[0];
				
				if (p1 != p2)	// Gemination will be covered by a separate process (1.0)
				{
					// Chance of representation ~= f(.4 x 15^(commonness - 3))
					// 3 -> .559, 2 -> .069, 1 -> .007
					double probability = 0.4 * Math.pow(15, transProb[p1.segment.transitionCategory][p2.segment.transitionCategory] - 3)
											+ interludeOffset;
					
					if (leadProbability[p1.segment.transitionCategory] * followProbability[p2.segment.transitionCategory] < probability)
						p1.addInterlude(medialOnsets.getMembersOfLength(1).get(j));
				}
			}
			
			// Normalize probabilities and sort the current coda's interlude list according to them.
			p1.followers.normalizeAll();
			p1.followers.sortAll();
			p1.followers.setLengthProbabilities(baseOnsetClusterChance);
		}
		
		// TODO: Temporary feature: remove codas with no interludes.
		// In the future, we may want to include these phonemes in the terminal coda, but those will be
		// handled by a separate inventory.
		medialCodas.pruneMembersWithoutFollowers();
		
		medialCodas.scaleProbabilityByFollowerCount();
		medialCodas.normalizeAll();
		medialCodas.sortAll();
		medialCodas.setLengthProbabilities(baseCodaClusterChance);
	}
		
	/**
	 * Sets base chances for heavy/light rimes, medial onsets, and medial/terminal codas. These values are used
	 * in NameAssembly to determine the weights of transitions between nodes.
	 * 
	 * Note that some liberty is taken with the use of 'rime' in this program; here, rime is the series of syllable
	 * segments that determines syllable weight and it therefore, because weight determination is based on Latin rules,
	 * includes the onset of the following syllable.
	 * 
	 * @since	1.0
	 */
	private void setBaseChances()
	{
		// Chance of a name starting with a vowel
		baseEmptyInitialOnsetChance = Math.max(rng.nextGaussian() * emptyInitialOnsetProminenceStdev + emptyInitialOnsetProminenceMean, 0);
		
		double baseCodaChance, codaLocationBalance;
		LogNormalDistribution logNormal;
		
		// Base medial onset chance		
		logNormal = new LogNormalDistribution(baseOnsetChanceMean, baseOnsetChanceStdev);
		logNormal.reseedRandomGenerator(rng.nextLong());
		
		if (counts[SIMPLE_NUCLEI_WITH_HIATUS] > 0)
			baseMedialOnsetChance = 1 - (logNormal.sample() - baseOnsetChanceOffset);
		else
			baseMedialOnsetChance = 0.5f;
		
		baseMedialOnsetChance = Math.max(Math.min(baseMedialOnsetChance, 1), 0);
		
		// Base medial and terminal coda chances
		if (maxCodaLength > 0)
		{
			baseCodaChance = logNormal.sample();
			logNormal = new LogNormalDistribution(baseCodaChanceMean, baseCodaChanceStdev);
			logNormal.reseedRandomGenerator(rng.nextLong());
		}
		else
			baseCodaChance = 0;
		
		codaLocationBalance = rng.nextGaussian() * codaLocationBalanceStdev + codaLocationBalanceMean;
		codaLocationBalance = Math.max(Math.min(codaLocationBalance, 1), 0);
		
		baseMedialCodaChance =   Math.max(Math.min(baseCodaChance * codaLocationBalance, 1), 0);
		baseTerminalCodaChance = Math.max(Math.min(baseCodaChance * (1 - codaLocationBalance), 1), 0);
		
		if (baseMedialCodaChance == 0)
			counts[Phonology.COMPOUND_INTERLUDES] = 0;
		
		// Correct cluster chances
		if (maxOnsetLength < 2)	baseOnsetClusterChance = 0;
		if (maxNucleusLength < 2)	baseDiphthongChance = 0;
		if (maxCodaLength < 2)		baseCodaClusterChance = 0;
		
//		baseSuffixOnsetChance = Math.min(Math.max(rng.nextDouble() * 2 - 0.5, 0), 1);
		baseSuffixOnsetChance = 0;
	}
	
	
	
	private void makeSuffixes()
	{
		suffixes = new SuffixLibrary();
		
		Name[] names = new Name[10];
		double[] probs = new double[10];
		
		for(int i = 0; i < 10; i++)
    		names[i] = ((SimpleAssembly)assembly).makeSuffix();
		for(int i = 0; i < 10; i++)
			suffixes.addName(names[i], rng.nextDouble());
		
		double exaggerationFactor = 2;
		suffixes.exaggerate(exaggerationFactor);
		suffixes.sort();
		suffixes.normalize();
	}

	/**
	 * Generates onset inventories by calling the recursive function generateMedialOnsets for each
	 * phoneme on the consonant inventory.
	 * @since	1.2
	 */
	private void generateOnsets(ConstituentLibrary lib)
	{
		for (Phoneme p : consonantInventory)
		{
			ArrayList<Phoneme> onset = new ArrayList<Phoneme>();
			onset.add(p);
			generateOnsets(onset, lib);
		}
	}
	
	private void generateNuclei(ConstituentLibrary lib)
	{
		for (Phoneme p : vowelInventory)
		{
			ArrayList<Phoneme> nucleus = new ArrayList<Phoneme>();
			nucleus.add(p);
			generateNuclei(nucleus, lib);
		}
	}
	
	
	private void generateCodas(ConstituentLibrary lib)
	{
		for (Phoneme p : consonantInventory)
		{
			ArrayList<Phoneme> coda = new ArrayList<Phoneme>();
			coda.add(p);
			generateCodas(coda, lib, Phonotactics.codaTransitions.length - 1);
		}
	}
	
	/**
	 * Discovers every available onset beginning with the given phoneme sequence. This method starts by adding 
	 * the current phoneme, then recurses on every onset that might be formed by adding one more phoneme to 
	 * the current one.
	 * @param	onset	An onset of arbitrary length
	 * @since	1.2
	 */
	private void generateOnsets(ArrayList<Phoneme> onset, ConstituentLibrary lib)
	{
		double prominence;
		
		// Start by adding the current phoneme.
		// To do this, its prominence (unnormalized probability) must be calculated.
		// For simple onsets, the prominence is merely equal to its sole phoneme's onset initial prominence.
		
		switch(lib.getLocation())
		{
			case MEDIAL: 
				prominence = ((ConsonantPhoneme) onset.get(0)).medialProminence;
				break;
			case INITIAL:
				prominence = ((ConsonantPhoneme) onset.get(0)).wordInitialProminence;
				break;
			default:
				return;
		}
	
		// For complex onsets, the initial onset prominence of the first phoneme is combined with the
		// onset cluster lead/follow prominences for every consecutive pair of phonemes by adding their
		// deviations from their common mean. The onsetClusterOffset is also applied for each pair.
		if (onset.size() > 1)
			for (int i = 0; i < onset.size() - 1; i++)
			{
				prominence += ((ConsonantPhoneme) onset.get(i)).onsetClusterLeadProminence + 
							  ((ConsonantPhoneme) onset.get(i+1)).onsetClusterFollowProminence - 2
							  - onsetClusterOffset;
				
				// Offset for tl/dl clusters
				if (onset.get(i).segment.properties[0] == ConsonantProperty.PLOSIVE &&
					onset.get(i).segment.properties[1] == ConsonantProperty.ALVEOLAR &&
					onset.get(i+1).segment.expression.equals("l"))
				{
					prominence -= onsetTlDlOffset;
				}
			}
		
		// Add the current onset to the appropriate onset inventory
		Constituent c = new Constituent(ConstituentType.ONSET, onset.toArray(new Phoneme[onset.size()]), prominence);
		lib.add(c);
		
		// If you've reached the largest cluster size, return immediately and do not examine large clusters
		if (onset.size() >= maxOnsetLength)
			return;
		
		// Otherwise, consider what additions to this cluster might be possible
		int ptCat = onset.get(onset.size() - 1).segment.transitionCategory; // get phonotactic transition category of the latest phoneme
		
		// For each phonotactic category to which the current phoneme might transition...
		for (int i = 0; i < validOnsetTransitions[ptCat].length; i++)
			if (validOnsetTransitions[ptCat][i])
			{
				// ... consider every member segment.
				for (int nextSound : Phonotactics.consonantCategories.get(i))
				{
					// If this Phonology has that segment, then create a new cluster by appending it to the current,
					// and recurse on it.
					for (int j = 0; j < consonantInventory.length; j++)
						if (consonantInventory[j].segment.id == nextSound)
						{
							ArrayList<Phoneme> copy = new ArrayList<Phoneme>();
							for (Phoneme p : onset)
								copy.add(p);
							copy.add(consonantInventory[j]);
							
							generateOnsets(copy, lib);
							j = consonantInventory.length;	// Segment found; stop searching
						}
				}
			}
	}

	private void generateNuclei(ArrayList<Phoneme> nucleus, ConstituentLibrary lib)
	{
		// Do not allow nuclei beginning with a vowel lengthener
		if (nucleus.get(0).segment.expression.equals(":"))
			return;
		
		// Start by adding the current phoneme.
		// To do this, its prominence (unnormalized probability) must be calculated.
		// For simple nuclei, the prominence is merely equal to its sole phoneme's onset initial prominence (we're talking
		// about nuclei here, but the variable does double duty).
		double prominence;
		switch (lib.getLocation())
		{
			case INITIAL:
				prominence = ((VowelPhoneme) nucleus.get(0)).wordInitialProminence;
				break;
			case MEDIAL:
				prominence = ((VowelPhoneme) nucleus.get(0)).medialProminence;
				break;
			case TERMINAL:
				prominence = ((VowelPhoneme) nucleus.get(0)).terminalProminence;
				break;
			case ROOT:
				prominence = ((VowelPhoneme) nucleus.get(0)).rootProminence;
				break;
			default:
				return;
		}
		
		// For complex nuclei, the maximum length of which is 2, the initial onset prominence of the first phoneme is
		// combined with the diphtong lead and follow prominences for pair by adding their deviations from their common mean.
		// The onsetClusterOffset is also applied.
		if (nucleus.size() > 1)
			for (int i = 0; i < nucleus.size() - 1; i++)
				prominence += ((VowelPhoneme) nucleus.get(i)).nucleusLeadProminence 
							+ ((VowelPhoneme) nucleus.get(i+1)).nucleusFollowProminence - 2 
							- diphthongOffset;
		
		// Add this nucleus to the appropriate nucleus inventory
		Constituent c = new Constituent(ConstituentType.NUCLEUS, nucleus.toArray(new Phoneme[nucleus.size()]), prominence);
		lib.add(c);
		
		// If you've reached the largest nucleus length, return without examining any longer diphthongs
		if (nucleus.size() >= maxNucleusLength)
			return;
		
		// Otherwise, consider what additions to this diphthong might be possible
		int ptCat = nucleus.get(nucleus.size() - 1).segment.transitionCategory; // get phonotactic transition category of the latest phoneme
		
		// For each phonotactic category to which the current phoneme might transition...
		for (int i = 0; i < validNucleusTransitions[ptCat].length; i++)
			if (validNucleusTransitions[ptCat][i])
			{
				// ... consider every member segment.
				for (int nextSound : Phonotactics.vowelCategories.get(i))
				{
					// If this Phonology has that segment, then create a new cluster by appending it to the current,
					// and recurse on it.
					for (int j = 0; j < vowelInventory.length; j++)
						if (vowelInventory[j].segment.id == nextSound)
						{
							ArrayList<Phoneme> copy = new ArrayList<Phoneme>();
							for (Phoneme p : nucleus)
								copy.add(p);
							copy.add(vowelInventory[j]);
							
							generateNuclei(copy, lib);
							j = vowelInventory.length;	// Segment found; stop searching
						}
				}
			}
	}

	/**
	 * Discovers every available coda beginning with the given phoneme sequence. This method starts by adding
	 * the current phoneme, then recurses on every coda that might be formed by adding one more phoneme to 
	 * the current one.
	 * @param	coda	A coda of arbitrary length
	 * @param	start	Index of the phonotactic category to start searching at
	 * @since	1.2
	 */
	private void generateCodas(ArrayList<Phoneme> coda, ConstituentLibrary lib, int start)
	{
		// Do not allow codas beginning with a glide (this feature is covered by diphthongs)
		if (coda.get(0).segment.properties[0].equals(ConsonantProperty.GLIDE))
			return;

		// Start by adding the current phoneme.
		// To do this, its prominence (unnormalized probability) must be calculated.
		// For simple codas, the prominence is merely equal to its sole phoneme's codaInitialProminence.
		double prominence;
		
		switch(lib.getLocation())
		{
			case MEDIAL: 
				prominence = ((ConsonantPhoneme) coda.get(0)).medialCodaProminence;
				break;
			case TERMINAL:
				prominence = ((ConsonantPhoneme) coda.get(0)).terminalCodaProminence;
				break;
			default:
				return;	
		}
		
		// For complex codas, the initial coda prominence of the first phoneme is combined with the
		// coda cluster lead/follow prominences for every consecutive pair of phonemes by adding their
		// deviations from their common mean. The codaClusterOffset is also applied for each pair.
		if (coda.size() > 1)
			for (int i = 0; i < coda.size() - 1; i++)
			{
				prominence += ((ConsonantPhoneme) coda.get(i)).codaClusterLeadProminence 
							+ ((ConsonantPhoneme) coda.get(i+1)).codaClusterFollowProminence - 2 
							- codaClusterOffset;
				
				// Penalize for dissimilar nasal-plosive clusters
				if (isDissonantNasalCluster(coda.get(i), coda.get(i+1)))
					prominence -= nasalDissonanceOffset;
			}
		
		// Add the current coda to the appropriate coda inventory
		Constituent c = new Constituent(ConstituentType.CODA, coda.toArray(new Phoneme[coda.size()]), prominence);
		lib.add(c);
		
		// If you've reached the largest cluster size, return immediately and do not examine large clusters
		if (coda.size() >= maxCodaLength)
			return;
		
		// Otherwise, consider how this cluster might continue
		int ptCat = coda.get(coda.size() - 1).segment.transitionCategory; // get phonotactic transition category of the latest phoneme
		
		// For each phonotactic category to which the current phoneme might transition...
		for (int i = Math.floorMod(ptCat-1, validCodaTransitions.length); i != start; i = Math.floorMod(i-1, validCodaTransitions.length))
			if (validCodaTransitions[ptCat][i])
			{
				// ... consider every member segment.
				for (int nextSound : Phonotactics.consonantCategories.get(i))
				{
					// If this Phonology has that segment, then create a new cluster by appending it to the current,
					// and recurse on it.
					for (int j = 0; j < consonantInventory.length; j++)
						if (consonantInventory[j].segment.id == nextSound)
						{
							ArrayList<Phoneme> copy = new ArrayList<Phoneme>();
							for (Phoneme p : coda)
								copy.add(p);
							copy.add(consonantInventory[j]);
							
							generateCodas(copy, lib, start);
							j = consonantInventory.length;	// Segment found; stop searching		
						}
				}
			}
	}
	
	/**
	 * Generates a sample of Phonologies and compiles statistics on them. The function prints the average
	 * time taken to generate a phonology, as well as the average value for each feature tracked by gatherStatistics(). 
	 * @param	count	The number of Phonologies to generate for the sample 
	 * @since	1.0
	 */
	static protected void massGatherStats(int count)
	{
		// Initialize counts
		int[] persistentCounts = new int[11];

		// Start timer
		long startTime = System.nanoTime();
		
		// Suppress output by having System print to a dummy OutputStream
		PrintStream original = System.out;
		PrintStream dummy = new PrintStream(new OutputStream() { public void write(int b) {} });
		System.setOut(dummy);
		
		// Generate the given number of Phonologies and record their feature counts
		for (int i = 0; i < count; i++)
		{
			Phonology p = new Phonology();
			for (int j = 0; j < persistentCounts.length; j++)
				persistentCounts[j] += p.counts[j]; 
		}
		
		// Reset System.out to its original value
		System.setOut(original);
		
		// End timer
		long endTime = System.nanoTime();
		double time = (endTime - startTime) / (count * 1000000);
		
		// Print findings
		System.out.println("AVERAGE\tSIMPLE\tCOMPLEX");
		System.out.println("ONSETS\t" + (persistentCounts[SIMPLE_ONSETS] / count) + "\t" + (persistentCounts[COMPLEX_ONSETS] / count));
		System.out.println("NUCLEI\t" + (persistentCounts[SIMPLE_NUCLEI] / count) + "\t" + (persistentCounts[COMPLEX_NUCLEI] / count));
		System.out.println("CODAS \t" + (persistentCounts[SIMPLE_CODAS]  / count) + "\t" + (persistentCounts[COMPLEX_CODAS]  / count));
		System.out.println("HIATUS\t" + (persistentCounts[SIMPLE_NUCLEI_WITH_HIATUS]  / count) + "\t" 
									  + (persistentCounts[COMPLEX_NUCLEI_WITH_HIATUS]  / count));
		System.out.println("COMPOUND INTERLUDES\t" + persistentCounts[COMPOUND_INTERLUDES] / count);
		System.out.println("LIGHT RIMES\t" + persistentCounts[LIGHT_RIMES] / count);
		System.out.println("HEAVY RIMES\t" + persistentCounts[HEAVY_RIMES] / count);
		
		System.out.println("Average time per language: " + time + "ms");
	}
	
	/**
	 * Returns true if a nasal cluster has unharmonious voicing, i.e.,
	 * 1.  the first segment is a NASAL, and either
	 * 2a. the second segment is a plosive and its place of articulation differs from the first, OR
	 * 2b. the second segment is postalveolar and the first is not nasal
	 * @param	p1	The first segment
	 * @param	p2	The second segment
	 * @since	1.0
	 */
	private boolean isDissonantNasalCluster(Phoneme p1, Phoneme p2)
	{
		if (p1.segment.properties[0] == ConsonantProperty.NASAL &&
				((p2.segment.properties[0] == ConsonantProperty.PLOSIVE && p1.segment.properties[1] != p2.segment.properties[1]) || 
				 (p2.segment.properties[1] == ConsonantProperty.POSTALVEOLAR && p1.segment.properties[1] != ConsonantProperty.ALVEOLAR)))
			{
				return true;
			}
		
		return false;
	}
	
	/**
	 * Returns true if a cluster disagrees in voicing, i.e.,
	 * 1.  both segments are plosives, affricates, or fricatives, and either
	 * 2a. the first is voiced and the second is unvoiced, or
	 * 2b. vice versa
	 * @param	p1	The first segment
	 * @param	p2	The second segment
	 * @since	1.0
	 * */
	private boolean isUnequalVoicing(Phoneme p1, Phoneme p2)
	{
		SegmentProperty place1 = p1.segment.properties[0];
		SegmentProperty place2 = p2.segment.properties[0];
		SegmentProperty voice1 = p1.segment.properties[1];
		SegmentProperty voice2 = p2.segment.properties[1];
		
		if ((place1 == ConsonantProperty.PLOSIVE || place1 == ConsonantProperty.AFFRICATE || place1 == ConsonantProperty.FRICATIVE) &&
			(place2 == ConsonantProperty.PLOSIVE || place2 == ConsonantProperty.AFFRICATE || place2 == ConsonantProperty.FRICATIVE) &&
			(voice1 == ConsonantProperty.VOICED  || voice1 == ConsonantProperty.VOICELESS) &&
			(voice2 == ConsonantProperty.VOICED  || voice2 == ConsonantProperty.VOICELESS) &&
			(voice1 != voice2))
			{
				return true;
			}
		
		return false;
	}
	
	/**
	 * Generates and returns a random name from this Phonology.
	 * @since	1.0
	 */
	public Name makeName()
	{
		return assembly.makeName();
	}
	
	/**
	 * Generates and returns a list of random names from this Phonology.
	 * 
	 * @param	number	The number of names to generate
	 * @return	A List of names, as strings
	 * @since	1.0
	 */
	public List<Name> makeNames(int number)
	{
		ArrayList<Name> names = new ArrayList<Name>();
		
		for (int i = 0; i < number; i++)
		{
			Name name = assembly.makeName();
			names.add(name);
		}
			
		
		// Sort the names alphabetically
//		Collections.sort(names);
		
		return names;
	}
	
	/**
	 * Prints various data about the current Phonology in great depth, including the contents of inventories,
	 * the statistics of the Phonology's stress system, and the chances of light and heavy rimes in weak and
	 * strong positions.
	 * @since	1.0
	 */
	public void printPhonology()
	{
		// Print inventories
		for (int i = 1; i <= maxOnsetLength; i++)
			printInventory(medialOnsets.getMembersOfLength(i));
		for (int i = 1; i <= maxCodaLength; i++)
			printInventory(medialCodas.getMembersOfLength(i));
		for (int i = 1; i <= maxNucleusLength; i++)
			printInventory(medialNuclei.getMembersOfLength(i));
	}
	
	/**
	 * Print every syllable segment in a given ArrayList
	 * @param	list	The list to be printed
	 * @since	1.0
	 */
	public void printInventory(ArrayList<Constituent> list)
	{
		if (list.size() == 0)
			return;
	
		System.out.println(list.get(0).type + " " + list.get(0).content.length);
		for (Constituent c : list)
			System.out.printf("%s\t%.3f\n", c, (c.probability / 1));
		
		System.out.println();
	}
	
	public void printHiatus()
	{
		for (VowelPhoneme p : vowelInventory)
		{
			System.out.println(p.segment.expression + ":");
			ConstituentLibrary[] libs = new ConstituentLibrary[] { p.followers, p.terminalFollowers, 
					p.rootFollowers };
			
			for (int j = 0; j < libs.length; j++)
			{
				System.out.print(libs[j].getLocation() + "  \t");
				for (int i = 1; i <= libs[j].maxLength(); i++)
				{
					for (Constituent c : libs[j].getMembersOfLength(i))
						System.out.printf("%s %.2f\t", c, c.probability * libs[j].getLengthProbability(c.size()));
				}
				System.out.println();
			}
		}
	}
	
	/**
	 * Return an array containing linguistic data about the Phonology. Each array item represents a different
	 * set of information:
	 * 
	 * 0. Medial and terminal syllable structure
	 * 1. Consonant inventory
	 * 2. Vowel inventory
	 * 
	 * @return	An assortment of linguistic data about this Phonology	
	 * @since	1.1.2
	 */
	public LanguageData getLanguageData()
	{
		return new LanguageData(this);
	}
	
	public void compareOnsets()
	{
		for (int i = 1; i <= Math.max(maxOnsetLength, maxCodaLength); i++)
		{
			ArrayList<Constituent> list = new ArrayList<Constituent>()
			{	
				public boolean add(Constituent c)
				{
					Iterator itr = this.iterator();
					while (itr.hasNext())
					{
						Constituent next = (Constituent) itr.next();
						if (c.sameSequence(next))
							return false;
					}
					super.add(c);
					return true;
				}
			};
			
			// Make combined set
			ConstituentLibrary[] libs = new ConstituentLibrary[] { medialOnsets, initialOnsets, medialCodas,
																	terminalCodas };
			
			for (ConstituentLibrary lib : libs)
				if (lib != null && lib.maxLength() >= i)
					for (Constituent c : lib.getMembersOfLength(i))
						list.add(c);
			
			// Print set
			for (Constituent c : list)
			{
				String result = c.toString() + "\t";
				
				System.out.print(result);
				
				
				
				for (ConstituentLibrary lib : libs)
				{
					double prob = 0;
					if (lib != null && i <= lib.maxLength())
						for (Constituent onset : lib.getMembersOfLength(i))
							if (onset.sameSequence(c))
							{
								prob = onset.probability;
								break;
							}
					
					if (prob == 0)
						System.out.print("    0\t");
					else
						System.out.printf("%.3f\t", prob);
				}
				
				System.out.println();
			}
			System.out.println();
		}
		
	}
	
	public void compareNuclei()
	{
		for (int i = 1; i <= maxNucleusLength; i++)
		{
			ArrayList<Constituent> list = new ArrayList<Constituent>()
			{	
				public boolean add(Constituent c)
				{
					Iterator itr = this.iterator();
					while (itr.hasNext())
					{
						Constituent next = (Constituent) itr.next();
						if (c.sameSequence(next))
							return false;
					}
					super.add(c);
					return true;
				}
			};
			
			// Make combined set
			ConstituentLibrary[] libs = new ConstituentLibrary[] { medialNuclei, initialNuclei, terminalNuclei,
																	rootNuclei };
			
			for (ConstituentLibrary lib : libs)
				if (lib != null && lib.maxLength() >= i)
					for (Constituent c : lib.getMembersOfLength(i))
						list.add(c);
			
			// Print set
			for (Constituent c : list)
			{
				String result = c.toString() + "\t";
				
				System.out.print(result);
				
				
				
				for (ConstituentLibrary lib : libs)
				{
					double prob = 0;
					if (lib != null && i <= lib.maxLength())
						for (Constituent onset : lib.getMembersOfLength(i))
							if (onset.sameSequence(c))
							{
								prob = onset.probability;
								break;
							}
					
					if (prob == 0)
						System.out.print("    0\t");
					else
						System.out.printf("%.3f\t", prob);
				}
				
				System.out.println();
			}
			System.out.println();
		}
		
	}
	
	/**
	 * A phoneme, or basic unit of sound. A Phoneme is an instance of a Segment specific to a given Phonology;
	 * the Segment determines what sound it makes, but the Phoneme includes its own rules for how that sound
	 * is used in the language. Accordingly, the Phoneme object includes numerous prominence values, as well
	 * as (if appropriate) an inventory of interludes available to that sound.
	 * @since	1.0
	 */
	abstract class Phoneme
	{
		Phonology parent;
		Segment segment;
		
		// Interlude properties
		ConstituentLibrary followers;
		
		// Prominences
		double medialProminence;
		double wordInitialProminence;
		double interludeLeadProminence;		
		double interludeFollowProminence;
		
		/**
		 * This constructor sets all the appropriate prominence values, according to whether the Phoneme
		 * is a consonant or a vowel.
		 * @param	parent		The phonology to which this Phoneme belongs
		 * @param	segment		The phonetic segment that characterizes this phoneme
		 * @since	1.0 
		 */
		public Phoneme(Segment segment)
		{
			parent = thisPhonology;
			this.segment = segment;
			followers = null;
		}
		
		abstract boolean isConsonant();
		
		/**
		 * Adds a SyllableSegment to this Phoneme's interlude inventory. If this Phoneme represents a consonant,
		 * the SyllableSegment represents an onset that may follow when this Phoneme is used as a coda. If this
		 * Phoneme represents a vowel, the SyllableSegment represents a nucleus that may follow in hiatus.
		 * @param	c	A coda or nucleus that may follow this Phoneme
		 * @since	1.0
		 */
		protected void addInterlude(Constituent c)
		{
			// If interludeLeadProminence <= 0, this phoneme does not lead in interludes/hiatus
			if (interludeLeadProminence <= 0)
				return;
			
			// Calculate interlude's probability.
			// Base probability equals sum of following segment's interludeFollow and onsetInitial prominences
			double probability = c.content[0].interludeFollowProminence;
			probability += c.content[0].medialProminence - 1;
			
			// Apply nasal dissonance inhibitor, if relevant
			if (segment.isConsonant() && isDissonantNasalCluster(this, c.content[0]))
				probability -= nasalDissonanceOffset;
			
			// If probability is positive, add this interlude
			if (probability > 0)
			{
				followers.add(new Constituent(c, probability));
			}
			
			// Add any possible clusters, too. Examine onset clusters if this is a consonantal interlude ...
			if (segment.isConsonant())
				for (int i = 1; i < medialOnsets.maxLength(); i++)
				{
					for (Constituent onset : medialOnsets.getMembersOfLength(i + 1))
						if (onset.content[0] == c.content[0])
						{
							// Set base probability equal to the next segment's prominence
							probability = onset.probability;
							
							// Apply offsets, if relevant
							if (isDissonantNasalCluster(this, onset.content[0]))
								probability -= nasalDissonanceOffset;
							
							if (isUnequalVoicing(this, onset.content[0]))
								probability -= unequalVoicingOffset;
							
							// If probability is positive, add this interlude
							if (probability > 0)
								followers.add(new Constituent(onset, probability));
						}
				}
			// ... or, if this is a hiatus, look at diphthongs
			else if (medialNuclei.maxLength() == 2)
			{
				for (Constituent diphthong : medialNuclei.getMembersOfLength(2))
					if (diphthong.content[0] == c.content[0])
					{
						// Set base probability equal to the next segment's prominence
						probability = diphthong.probability;
						
						// If probability is positive, add this interlude
						if (probability > 0)
							followers.add(new Constituent(diphthong, probability));
					}
			}
//			Print interlude statistics
//			System.out.printf("%.3f (%.3f + %,3f)", probability, p.interludeFollowProminence, p.onsetInitialProminence);
		}
		
		public String toString()
		{
			return "[" + segment.expression + "]";
		}
	}
	
	class ConsonantPhoneme extends Phoneme
	{
		double onsetClusterLeadProminence;
		double onsetClusterFollowProminence;
		double medialCodaProminence;
		double terminalCodaProminence;
		double codaClusterLeadProminence;
		double codaClusterFollowProminence;
		
		public ConsonantPhoneme(Segment segment)
		{
			super(segment);
			
			// Assign default prominence values
			medialProminence			 = 1;
			wordInitialProminence	 	 = 1;
			medialCodaProminence		 = 1;
			terminalCodaProminence		 = 1;
			
			onsetClusterLeadProminence   = 1;
			onsetClusterFollowProminence = 1;
			codaClusterLeadProminence    = 1;
			codaClusterFollowProminence  = 1;
			interludeLeadProminence  	 = 1;
			interludeFollowProminence 	 = 1;
			
			// Apply offsets
			if (segment.expression.equals("ng"))
			{
				medialProminence    -= onsetNgOffset;
				wordInitialProminence	  -= onsetNgOffset;
				interludeFollowProminence -= onsetNgOffset;
			}
			else if (segment.expression.equals("'"))
			{
				medialCodaProminence		-= codaGlottalStopOffset;
				codaClusterLeadProminence	-= codaGlottalStopOffset;
				codaClusterFollowProminence -= codaGlottalStopOffset;
			}
			
			/* Calculate prominence values. 
			 * Math note: initialProminence is the result of combining all the prominence values of the
			 * segment's properties, with mean 1. The deviance of each prominence is scaled by the root of
			 * the number of the segment's properties; this ensures that all intialProminence values are
			 * distributed, in effect, with the same standard deviation, regardless of how many values are
			 * added to make it (normally, adding random variables increases the stdev of the sum). The
			 * same is true of the cluster prominence values as well.
			 */
			for (ConsonantProperty s : ((Consonant) segment).properties)
			{
				// Initial properties
				double deviance = baseConsonantRatings.getRating(s.ordinal()) - 1;
				deviance /= Math.sqrt(segment.properties.length);
				medialProminence += deviance;
				
				deviance = wordInitialRatings.getRating(s.ordinal()) - 1;
				deviance /= Math.sqrt(segment.properties.length);
				wordInitialProminence += deviance;
				
				if (maxCodaLength > 0)
				{
					deviance = baseCodaRatings.getRating(s.ordinal()) - 1;
					deviance /= Math.sqrt(segment.properties.length);
					medialCodaProminence += deviance;
					
					deviance = terminalCodaRatings.getRating(s.ordinal()) - 1;
					deviance /= Math.sqrt(segment.properties.length);
					terminalCodaProminence += deviance;
				}
				
				// Onset cluster properties
				if (maxOnsetLength > 1)
				{
					deviance = onsetClusterLeadRatings.getRating(s.ordinal()) - 1;
					deviance /= Math.sqrt(segment.properties.length);
					onsetClusterLeadProminence += deviance;
					
					deviance = onsetClusterFollowRatings.getRating(s.ordinal()) - 1;
					deviance /= Math.sqrt(segment.properties.length);
					onsetClusterFollowProminence += deviance;
				}
				
				// Coda cluster properties
				if (maxCodaLength > 1)
				{
					deviance = codaClusterLeadRatings.getRating(s.ordinal()) - 1;
					deviance /= Math.sqrt(segment.properties.length);
					codaClusterLeadProminence += deviance;
					
					deviance = codaClusterFollowRatings.getRating(s.ordinal()) - 1;
					deviance /= Math.sqrt(segment.properties.length);
					codaClusterFollowProminence += deviance;
					
					deviance = interludeLeadRatings.getRating(s.ordinal()) - 1;
					deviance /= Math.sqrt(segment.properties.length);
					interludeLeadProminence += deviance;
					
					deviance = interludeFollowRatings.getRating(s.ordinal()) - 1;
					deviance /= Math.sqrt(segment.properties.length);
					interludeFollowProminence += deviance;
				}
			}
		}
		
		public boolean isConsonant()
		{
			return true;
		}
	}
	
	class VowelPhoneme extends Phoneme
	{
		double nucleusLeadProminence;
		double nucleusFollowProminence;
		double terminalProminence;
		double rootProminence;
		
		double hiatusMedialSyllableEntropy;	// entropy for a medial syllable starting with a vowel
		double hiatusConsonantTerminationEntropy;
		double hiatusVowelTerminationEntropy;
		double hiatusRootSyllableEntropy;
		
		ConstituentLibrary terminalFollowers;
		ConstituentLibrary rootFollowers;
		
		public VowelPhoneme(Segment segment)
		{
			super(segment);
			
			// Assign initial prominence values
			medialProminence			= 1;	// this functions as the nucleus initial prominence here
			wordInitialProminence		= 1;
			terminalProminence			= 1;
			rootProminence				= 1;
			nucleusLeadProminence 		= 1;
			nucleusFollowProminence 	= 1;
			interludeLeadProminence  	= 1;
			interludeFollowProminence 	= 1;
			
			double hiatusMedialSyllableEntropy			= 0;
			double hiatusConsonantTerminationEntropy	= 0;
			double hiatusVowelTerminationEntropy		= 0;
			double hiatusRootSyllableEntropy			= 0;
			
			// Apply offsets
			if (segment.expression.equals(":"))
			{
				medialProminence = Integer.MIN_VALUE;
			}
			
			// Calculate prominence values
			for (VowelProperty s : ((Vowel) segment).properties)
			{
				double deviance = baseVowelRatings.getRating(s.ordinal()) - 1;
				deviance /= Math.sqrt(segment.properties.length);
				medialProminence += deviance;
				
				deviance = initialNucleusRatings.getRating(s.ordinal()) - 1;
				deviance /= Math.sqrt(segment.properties.length);
				wordInitialProminence += deviance;
				
				deviance = terminalNucleusRatings.getRating(s.ordinal()) - 1;
				deviance /= Math.sqrt(segment.properties.length);
				terminalProminence += deviance;
				
				deviance = rootNucleusRatings.getRating(s.ordinal()) - 1;
				deviance /= Math.sqrt(segment.properties.length);
				rootProminence += deviance;
				
				deviance = hiatusLeadRatings.getRating(s.ordinal()) - 1;
				deviance /= Math.sqrt(segment.properties.length);
				interludeLeadProminence += deviance;
				
				deviance = hiatusFollowRatings.getRating(s.ordinal()) - 1;
				deviance /= Math.sqrt(segment.properties.length);
				interludeFollowProminence += deviance;
				
				if (maxNucleusLength > 1)
				{
					deviance = diphthongLeadRatings.getRating(s.ordinal()) - 1;
					deviance /= Math.sqrt(segment.properties.length);
					nucleusLeadProminence += deviance;
					
					deviance = diphthongFollowRatings.getRating(s.ordinal()) - 1;
					deviance /= Math.sqrt(segment.properties.length);
					nucleusFollowProminence += deviance;	
				}
				else
				{
					nucleusLeadProminence = 0;
					nucleusFollowProminence = 0;
				}
			}
			
//			System.out.printf("%s\t%.3f\t%.3f\t%.3f\n", segment.expression, onsetInitialProminence, nucleusLeadProminence, nucleusFollowProminence);
		}
		
		public boolean isConsonant()
		{
			return false;
		}
		
		protected void addInterlude(Constituent c, ConstituentLocation location)
		{
			// If interludeLeadProminence <= 0, this phoneme does not lead in interludes/hiatus
			if (interludeLeadProminence <= 0)
			{
				System.out.println("Rejecting " + c + " from " + location + " " + this);
				return;
			}
			
			// Calculate interlude's probability.
			// Base probability equals sum of following segment's interludeFollow and onsetInitial prominences
			double probability = c.content[0].interludeFollowProminence;
			
			
			ConstituentLibrary sourceLibrary, targetLibrary;
			
			switch(location)
			{
				case MEDIAL:
					sourceLibrary = medialNuclei;
					targetLibrary = followers;
					probability += c.content[0].medialProminence - 1;
					break;
				case TERMINAL:
					sourceLibrary = terminalNuclei;
					targetLibrary = terminalFollowers;
					probability += ((VowelPhoneme) c.content[0]).terminalProminence - 1;
					break;
				case ROOT:
					sourceLibrary = rootNuclei;
					targetLibrary = rootFollowers;
					probability += ((VowelPhoneme) c.content[0]).rootProminence - 1;
					break;
				default:
					return;
			}
			
			// If probability is positive, add this interlude
			if (probability > 0)
			{
				targetLibrary.add(new Constituent(c, probability));
			}
			
			
			// Consider adding diphthongs
			if (sourceLibrary.maxLength() == 2)
			{
				for (Constituent diphthong : sourceLibrary.getMembersOfLength(2))
					if (diphthong.content[0] == c.content[0])
					{
						// Set base probability equal to the next segment's prominence
						probability = diphthong.probability;
						
						// If probability is positive, add this interlude
						if (probability > 0)
							targetLibrary.add(new Constituent(diphthong, probability));
					}
			}
//			Print interlude statistics
//			System.out.printf("%.3f (%.3f + %,3f)", probability, p.interludeFollowProminence, p.onsetInitialProminence);
		}
	}

	/**
	 * Represents a sequence of 1 or more consecutive Phonemes in a particular position in a word -
	 * either an onset, a nucleus, or a coda.
	 * @since	1.0
	 */
	class Constituent implements Comparable<Constituent>
	{
		ConstituentType type;
		Phoneme[] content;
		double probability;
				
		/**
		 * Constructor sets the syllable segment's essential parameters.
		 * @param	type		Syllable segment's type (onset, nucleus, coda)
		 * @param	content		Sequence of Phonemes comprising the segment
		 * @param	probability	Probability of this segment appearing out of all syllable segments of same type and length
		 * @since	1.0
		 */
		public Constituent (ConstituentType type, Phoneme[] content, double probability)
		{
			this.type = type;
			this.content = content;
			this.probability = probability;
		}
		
		/**
		 * Creates a copy of the given Constituent with a new probability value
		 * @param old
		 * @param probability
		 * @since 1.2
		 */
		public Constituent (Constituent old, double probability)
		{
			this.type = old.type;
			this.content = old.content;
			this.probability = probability;
		}
		
		/**
		 * Copy constructor.
		 * @param	other	Syllable segment to be copied
		 * @since	1.0
		 */
		public Constituent(Constituent other)
		{
			this.type = other.type;
			this.content = other.content;
			this.probability = other.probability;
		}
		
		/**
		 * @return	The number of Phonemes in this Constituent
		 * @since	1.2
		 */
		public int size()
		{
			return content.length;
		}
		
		/**
		 * @return	The last Phoneme in this segment's sequence of Phonemes.
		 * @since	1.0
		 */
		public Phoneme lastPhoneme()
		{
			if (content[content.length - 1].segment.expression.equals(":"))
				return content[content.length - 2];
			else
				return content[content.length - 1];
		}
		
		public ConstituentLibrary followers()
		{
			return lastPhoneme().followers;
		}
		
		
		/**
		 * Returns a string containing the segment's constituent Phonemes in sequence.
		 * @return	The content of the syllable segment, in string form
		 * @since	1.0 
		 */
		public String toString()
		{
			String result = "";
			for (Phoneme p : content)
				result += p.segment.expression;
			return result;
		}
		
		public boolean sameSequence(Constituent other)
		{
			if (size() != other.size())
				return false;
			for (int i = 0 ; i < content.length; i++)
				if (content[i] != other.content[i])
					return false;
			return true;
		}

		/**
		 * Compares this segment's probability to another segment's; returns 1 if this segment's probability is higher,
		 * -1 if it is lower, and 0 if they are equal.
		 * @return	An int representing the relationship between this segment's probability and that of another segment
		 * @since	1.0
		 */
		public int compareTo(Constituent c)
		{
			if (probability > c.probability)
				return 1;
			else if (probability < c.probability)
				return -1;
			return 0;
		}
	}
	
	/**
	 * Sets the seed to the given value.
	 * @param 	newSeed		the value to which to set the seed
	 */
	public void setSeed(long newSeed)
	{
		rng.setSeed(newSeed);
	}
	
	/**
	 * Returns the original seed for the phonology's random number generator.
	 * @return	The Phonology's original seed
	 */
	public long getSeed()
	{
		return seed;
	}
	
	class PhoneticRatings
	{
		private double[] ratings;
		boolean[] propertiesRepresented;
		SegmentProperty[] properties;
		
		public PhoneticRatings(boolean consonant, double stdev, double mean)
		{
			if (consonant)
			{
				properties = ConsonantProperty.values();
				propertiesRepresented = consonantPropertiesRepresented;
			}
			else
			{
				properties = VowelProperty.values();
				propertiesRepresented = vowelPropertiesRepresented;
			}
			
			ratings = new double[properties.length];
			
			for (int i = 0; i < ratings.length; i++)
				if (propertiesRepresented[i])
					ratings[i] = rng.nextGaussian() * stdev + mean;
		}
		
		/**
		 * Copy constructor
		 * @param other	The PhoneticRatings to be copied
		 */
		public PhoneticRatings(PhoneticRatings other)
		{
			ratings = new double[other.properties.length];
			for (int i = 0; i < ratings.length; i++)
				ratings[i] = other.getRating(i);
			
			this.properties = other.properties;
			this.propertiesRepresented = other.propertiesRepresented;
		}
		
		public void disturb(double stdev)
		{
			for (int i = 0; i < ratings.length; i++)
				ratings[i] = rng.nextGaussian() * stdev + ratings[i];
		}
		
		public void offset(double offset)
		{
			for (int i = 0; i < ratings.length; i++)
				ratings[i] = ratings[i] + offset;
		}
		
		public void offset(double[] offsets)
		{
			if (offsets.length != ratings.length)
				return;
			
			for (int i = 0; i < ratings.length; i++)
				ratings[i] = ratings[i] + offsets[i];
		}
		
		public void exaggerate(double power)
		{
			for (int i = 0; i < ratings.length; i++)
				ratings[i] = Math.pow(ratings[i], power);
		}
		
		public double getRating(int index)
		{
			return ratings[index];
		}
		
		public void setRating(int index, double value)
		{
			ratings[index] = value;
		}
		
		public int size()
		{
			return ratings.length;
		}
	}
}

/**
 * The structural role of a Constituent (a sequence of Phonemes) in a syllable. 
 * @since	1.0
 */
enum ConstituentType { ONSET, NUCLEUS, CODA; }
enum ConstituentLocation { MEDIAL, INITIAL, TERMINAL, ROOT }