/** Copyright 2018, 2019 Clayton Cooper
 *	
 *	This file is part of gengen2.
 *
 *	gengen2 is free software: you can redistribute it and/or modify
 *	it under the terms of the GNU General Public License as published by
 *	the Free Software Foundation, either version 3 of the License, or
 *	(at your option) any later version.
 *
 *	gengen2 is distributed in the hope that it will be useful,
 *	but WITHOUT ANY WARRANTY; without even the implied warranty of
 *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *	GNU General Public License for more details.
 *
 *	You should have received a copy of the GNU General Public License
 *	along with gengen2.  If not, see <http://www.gnu.org/licenses/>.
 * 
 */

package gengenv2;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.Random;

import org.apache.commons.math3.distribution.LogNormalDistribution;

import gengenv2.enums.*;
import gengenv2.structures.*;


/**
 * An individual, complete Phonology, or language. Each Phonology contains its own set of sounds (phonemic inventory),
 * rules for assembling those sounds into syllables and words (phonotactics), rules for syllable weight and stress
 * (prosody), and a host of other assorted parameters that govern the shape these features take. All Phonologies
 * share the same system of representing sounds in letters (orthography), which is (mostly) intuitive and (mostly)
 * unambiguous. A Phonology uses these features to generate new names that are sound linguistically similar to each
 * other,  but distinct from those generated by other Phonologies.
 * 
 * @author	Clayton Cooper
 * @version	1.0
 * @since	1.0
 */
public class Phonology
{
	protected Random rng;
	private String name;
	private long seed;
	
	/*
	 * High level features
	 * 
	 * 
	 */
	
	
	/* Auxiliary systems
	 * 
	 * These are other special systems used by the Phonology to aid in name-making, defined in their own classes.
	 * MorphemeAssembly creates words using phonology's rules for syllable structure. stressRules represents the 
	 * Phonology's rules for stress and rhythm, and is used to assign stress to words MorphemeAssembly has made.
	 */
	FeatureSet features;
	MorphemeAssembly assembly;
//	StressRules stressRules;
//	SuffixLibrary suffixes;
//	CombinationRules combinationRules;
	
	/* 
	 * Feature references
	 */
	
	VowelPhoneme longVowel;
	
	/* Syllable Constituent libraries
	 * 
	 * Libraries containing every onset, nucleus, and coda available to the language in different contexts.
	 */
	
	protected ConstituentLibrary medialOnsets;
	protected ConstituentLibrary medialCodas;
	protected ConstituentLibrary medialNuclei;
	protected ConstituentLibrary initialOnsets;
	protected ConstituentLibrary initialNuclei;
	protected ConstituentLibrary terminalCodas;
	protected ConstituentLibrary terminalNuclei;
	protected ConstituentLibrary rootNuclei;
	
	protected MorphemeLibrary roots;
	
	/* Prominence ratings
	 * 
	 *  Through repeated use in variable names, "prominence" has become, for me, something of a technical term, 
	 *  denoting a raw measure of how common a phonological unit (a Phoneme, a phonetic Property, a syllable 
	 *  Constituent) is. The value of a prominence rating doesn't have any meaning on its own, but are frequently
	 *  manipulated and normalized to produce probabilities for different outcomes.
	 *  
	 *  The "lead" and "follow" prominences represent a phoneme's tendency to precede or follow other sounds within
	 *  a consonant cluster, diphthong, or interlude, and are used to determine how commonplace each such cluster is.
	 */
	
	boolean[] consonantPropertiesRepresented;	// Records of which phonetic properties this language
	boolean[] vowelPropertiesRepresented;		// recognizes. Used in the Phoneme selection process
	
	// Basic ratings
	PhoneticRatings baseConsonantRatings;	// Basic ratings for consonant sounds. Other consonant ratings are
											// derived from this. Also represents prominence for medial onsets.
	PhoneticRatings baseVowelRatings;		// As above, for vowels. Also represents prominence for medial nuclei.
	
	// Derived ratings
	PhoneticRatings baseCodaRatings;		// Basic ratings for codas. Other coda ratings are derived form this 
	PhoneticRatings initialOnsetRatings;	// Governs prevalence of consonant sounds in word-initial onsets
	PhoneticRatings terminalCodaRatings;	// Governs prevalence of consonant sounds in word-final codas
	PhoneticRatings	initialNucleusRatings;	// Governs prevalence of vowel sounds in word-initial nuclei
	PhoneticRatings	terminalNucleusRatings;	// Governs prevalence of vowel sounds in word-final nuclei
	PhoneticRatings rootNucleusRatings;		// Governs prevalence of vowel sounds in root endings
	
	// Lead and follow ratings
	PhoneticRatings onsetClusterLeadRatings;		// Consonant clusters in onsets
	PhoneticRatings onsetClusterFollowRatings;
	PhoneticRatings codaClusterLeadRatings;			// Consonant clusters in codas
	PhoneticRatings codaClusterFollowRatings;
	PhoneticRatings bridgeLeadRatings;			// Consonant clusters across syllable boundaries
	PhoneticRatings bridgeFollowRatings;
	PhoneticRatings diphthongLeadRatings;			// Vowel clusters (diphthongs) in nuclei
	PhoneticRatings diphthongFollowRatings;
	PhoneticRatings hiatusLeadRatings;				// Vowel sequences across syllable boundaries
	PhoneticRatings hiatusFollowRatings;
	
	/*
	 * Phoneme inventories
	 * 	
	 * Arrays containing of all the phonemes (potentially) in the Phonology. These are sorted into consonant and
	 * vowel inventories. Note that a phoneme appearing in one of these inventories may still be absent from the
	 * language in practice if its prominence is 0 in every context.
	 */
	ConsonantPhoneme[] consonantInventory;	// List of CONSONANTS represented in this Phonology
	VowelPhoneme[] vowelInventory;			// List of VOWELS represented in this Phonology
	
	/*
	 * Constituent length limits
	 * 
	 *  Determine the maximum length a consonant cluster or diphthong may take. These values are generated in
	 *  makeBasicSyllableStructure() but may be reduced during generation if no clusters of sufficient length
	 *  are present in that language. This keeps methods from trying to pick a syllable segment from an empty
	 *  list if, say, a Phonology technically allows onset clusters of length 3 but doesn't actually have any.
	 *  
	 *  As of v1.2, these variables no longer tell the story, but are still used throughout this class as
	 *  general upper limits.
	 */
	private int maxOnsetLength;
	private int maxNucleusLength;
	private int maxCodaLength;
	
	/*
	 * Coda prominence variables
	 * 
	 * codaRatingOffset is a flat value subtracted from every coda prominence rating to manage the richness
	 * of the coda inventory. codaDisturbance governs how greatly the base prominences are disturbed to produce
	 * the coda prominence values, AS A PERCENTAGE of the codaRatingStdev. At 0, coda values are undisturbed 
	 * compared to the base values; at 1, they have essentially been rerolled from scratch.
	 */
	private double codaRatingOffset;
	private double codaDisturbance;
	
	/*
	 * General cluster offsets
	 * 
	 * Offset values are added to or subtracted from the prominence rating of consonant clusters or diphthongs to
	 * manage the diversity of such features in a Phonology. 
	 */
	private double onsetClusterOffset;
	private double codaClusterOffset;
	private double interludeOffset;
	private double diphthongOffset;
	private double geminateVowelOffset;
	private double hiatusProminenceOffset;
	
	/*
	 * Specific cluster offsets
	 * 
	 * These values are added to or subtracted from particular cluster prominence ratings in specific circumstances 
	 * to restrict their prominence to (the author's personal sense of) a more natural pattern.
	 */
	double onsetNgOffset;			// reduces the chance of a onset 'ng'
	double onsetTlDlOffset; 		// reduces the chances of an onset 'tl' or 'dl'
	double codaGlottalStopOffset;	// reduces the chances of a coda glottal stop (')
	double nasalDissonanceOffset;	// reduces the prevalence of coda nasal-plosive clusters that disagree in articulation
	double unequalVoicingOffset;	// reduces the prevalence of interludes that disagree in voicing
	
	/*
	 * Phonotactic properties
	 * 
	 * Values used in the determining where in a syllable certain sounds may appear. The ___CategoriesRepresented 
	 * arrays track which phonetic categories are present in a language (this can't be done just by consulting 
	 * their prominence ratings as categories with negative ratings may still be present), while the 
	 * valid___Transitions arrays dictate the phonotactic categories of which different phonemes might follow each 
	 * other within clusters.
	 */
	private boolean[] consonantCategoriesRepresented;
	private boolean[] vowelCategoriesRepresented;
	
	private boolean[][] validOnsetTransitions;
	private boolean[][] validNucleusTransitions;
	private boolean[][] validCodaTransitions;

	/*
	 * Occurrence coefficients
	 * 
	 * These are coefficients affecting the chances of certain features of syllables occurring. These are used in 
	 * the MorphemeAssembly class to determine the frequency of certain events occurring, usually by multiplying
	 * a log count of a certain feature to obtain an (unnormalized) probability value.
	 * 
	 * Cluster chances represent the chance of a marginally more complex syllable Constituent occurring. The
	 * likelihood of a certain length of Constituent occurring in a given position is proportionate its
	 * cluster coefficient raised to the power of that length (minus one). 
	 */
	protected double baseEmptyInitialOnsetChance;
//	protected double baseMedialOnsetChance;
	protected double baseMedialCodaChance;
	protected double baseTerminalCodaChance;
	protected double baseSuffixOnsetChance;
	protected double baseClusterChance;
	protected double baseDiphthongChance;
	protected double baseHiatusChance;
	protected double closedFinalSyllableChance;

	/*
	 * Generator properties
	 * 
	 * These static variables are properties of the generate itself and are used to determine the values of
	 * different features within a language that have a random component to them. Most of them represent the
	 * mean and standard deviation values for Gaussian random numbers.
	 */
	
	// Prominence means/stdevs
	static double baseClusterChanceStdev			= 0.015;
	static double baseClusterChanceMean				= 0.09;
	static double baseDiphthongChanceStdev			= 0.015;
	static double baseDiphthongChanceMean			= 0.09;
	static double baseMedialCodaChanceStdev			= 0.015;
	static double baseMedialCodaChanceMean			= 0.09;
	static double basicProminenceStdev				= 0.60;
	static double basicProminenceMean				= 0.85;
	static double basicCodaStdev					= 0.60;
	static double basicCodaMean						= 0.90;
	static double vowelProminenceStdev 				= 0.50;
	static double vowelProminenceMean				= 1.00;
	static double wordInitialStdev					= 0.25;
	static double wordInitialMean					= 0.25;
	static double emptyInitialOnsetProminenceMean   = 0.3;
	static double emptyInitialOnsetProminenceStdev  = 0.15;
	static double onsetClusterProminenceMean	 	= 0.1;
	static double onsetClusterProminenceStdev 		= 0.05;
	static double clusterLeadStdev    				= 0.50;
	static double clusterLeadMean					= 1.00;
	static double clusterFollowStdev  				= 0.50;
	static double clusterFollowMean					= 1.00;
	static double bridgeLeadStdev    				= 0.50;
	static double bridgeLeadMean					= 1.00;
	static double bridgeFollowStdev  				= 0.50;
	static double bridgeFollowMean					= 1.00;
	static double diphthongLeadStdev  				= 0.50;
	static double diphthongLeadMean					= 1.00;
	static double diphthongFollowStdev 				= 0.50;
	static double diphthongFollowMean				= 1.00;
	static double hiatusLeadStdev  					= 0.50;
	static double hiatusLeadMean  					= 1.00;
	static double hiatusFollowStdev					= 0.50;
	static double hiatusFollowMean					= 1.00;

	// Bounding values
	static double minimumOnsetClusterProminence		= 0.01; 
	static double minimumNucleusClusterProminence	= 0.01;
	static double minimumCodaClusterProminence		= 0.01;
	
	// Offset means/stdevs
	static double codaOffsetMean					= 0.4;
	static double codaOffsetStdev					= 0.4;
	static double onsetNgOffsetMean					= 2;
	static double onsetNgOffsetStdev				= 1;
	static double onsetTlDlOffsetMean				= 1;
	static double onsetTlDlOffsetStdev				= 0.5;
	static double codaGlottalStopOffsetMean			= 5;
	static double codaGlottalStopOffsetStdev		= 1;
	static double nasalDissonanceOffsetMean			= 2;
	static double nasalDissonanceOffsetStdev		= 1;
	static double unequalVoicingOffsetMean			= 1.25;
	static double unequalVoicingOffsetStdev			= 0.5;
	static double hiatusOffsetStdev					= 0.15;
	static double interludeOffsetStdev				= 0.15;
	
	// Base occurence chance means/stdevs 
	static double strongHeavyRimeChanceMean			= 0.8;
	static double strongHeavyRimeChanceStdev		= 0.2;
	static double weakHeavyRimeChanceMean			= 0.3;
	static double weakHeavyRimeChanceStdev			= 0.15;
	static double baseCodaChanceMean				= -0.5;
	static double baseCodaChanceStdev				= 0.5;
	static double codaLocationBalanceMean			= 0.4;
	static double codaLocationBalanceStdev			= 0.33;
	static double baseHiatusChanceMean				= 1;
	static double baseHiatusChanceStdev				= 0.2;
	static double baseOnsetChanceOffset				= 0.8;
	static double baseTerminalCodaChanceMean 		= 0.5;
	static double baseTerminalCodaChanceStdev		= 0.1;
	
	// Name assembly properties
	static double heavyRimeSuppressionFactor		= 1.5;
	
	// New variables
	Morphology morphology;
	
	/**
	 * Sets the rng to a specified seed before calling constructPhonology to set up the Phonology.
	 * @param	seed	The seed to be used for the random number generator
	 * @since	1.0
	 */
	public Phonology(long seed)
	{
		rng = PublicRandom.getRNG(PublicRandom.newRNG(seed));
		this.seed = seed;
		
		// Commence generation
		constructPhonology();
	}

	/**
	 * Sets the rng to a random seed before calling constructPhonology to set up the Phonology proper.
	 * @since	1.0
	 */
	public Phonology()
	{
		this(new Random().nextLong());
	}
	
	/**
	 * The main process by which a Phonology is set up. This creates a complete Phonology by invoking a series of methods
	 * each of which generates some part of the Phonology. The order of operations is important, as some methods depend
	 * on information generated by previous methods, or delete information that other methods use.
	 * @since	1.0
	 */
	private void constructPhonology()
	{
		System.out.println("Phonology Seed: " + seed);
		
		// Commence construction
		selectFeatures();
		
		determineClusterStatistics();
		determineProminence();
		selectSegments();
		
		// Populate inventories
		makeOnsets();
		makeNuclei();
		makeHiatus();
		
		if (features.medialCodas != Feature.NO || features.terminalCodas != Feature.NO)
			makeCodas();
		
		// Set base chances for use in the flowchart
		setBaseChances();		
		
		morphology = new Morphology(this);
		System.out.println(morphology);
		
		// Create flowchart
		assembly = new MorphemeAssembly(this);
		

		
//		makeSuffixes();
		
		// Create stress rules
//		stressRules = new StressRules();
		
		
		// Calculate entropy
//		System.out.println("ONSET CLUSTER ENTROPY (Max length: " + maxOnsetLength + "), " + initialOnsets.size() + " members");
//		initialOnsets.setClusterEntropy(ConstituentType.ONSET, maxOnsetLength);
//		for (int i = 0; i < maxOnsetLength; i++)
//			System.out.println("Length " + (i + 1) + ": " + initialOnsets.getClusterEntropy(ConstituentType.ONSET, i + 1));
//		
//		System.out.println("CODA CLUSTER ENTROPY (Max length: " + maxCodaLength + ")");
//		
//		if (terminalCodas != null)
//		{
//			terminalCodas.setClusterEntropy(ConstituentType.CODA, maxCodaLength);
//			for (int i = 0; i < maxCodaLength; i++)
//				System.out.println("Length " + (i + 1) + ": " + terminalCodas.getClusterEntropy(ConstituentType.CODA, i + 1));
//			
//			for (Constituent c : terminalCodas.getMembers())
//			{
//				for (int i = 0; i < maxCodaLength - 1; i++)
//					System.out.println(c + "\t" + (i + 1) + " followers: " + c.followers(ConstituentType.CODA).getClusterEntropy(ConstituentType.CODA, i + 1));
//				c.followers(ConstituentType.CODA).printMembers();
//				System.out.println();
//			}
//		}
//		
//		if (medialCodas != null)
//			for (Constituent c : medialCodas.getMembers())
//				for (int i = 0; i < maxCodaLength - 1; i++)
//				{
//					System.out.println(c + "\t" + (i + 1) + " followers: " + c.followers(ConstituentType.CODA).getClusterEntropy(ConstituentType.CODA, i + 1));
//				}
		
//		printClusters(initialOnsets);
//		printClusters(terminalCodas);
		
		initialOnsets.printMembers();
		rootNuclei.printMembers();
		System.out.println(rootNuclei + " ENTROPY (Max length: " + maxNucleusLength + "), " + rootNuclei.size() + " members");
		rootNuclei.setClusterEntropy(maxNucleusLength);
		for (int i = 0; i < maxNucleusLength; i++)
			System.out.println("Length " + (i + 1) + ": " + rootNuclei.getClusterEntropy(i + 1));
		
		medialNuclei.printMembers();

		// Generate roots
		makeRoots();
		
		// Generate noun classes 
		morphology.generateNounClasses();
		

	}
	
	/**
	 * Selects the high-level features of the language, such as syllable structure (what syllable Constituents
	 * are allowed, and where?), phonotactics (are clusters allowed? how long are they? is hiatus?), gemination
	 * of consonants and vowels.
	 * 
	 * @since	1.2 (1.0 as makeBasicSyllableStructure)
	 */
	private void selectFeatures()
	{
		int roll;
		
		features = new FeatureSet();
		
		// Feature: Initial onsets
		if (rng.nextInt(20) < 1)
			features.initialOnsets = Feature.REQUIRED;
		
		// Feature: Onset Clusters
		if (rng.nextInt(2) < 1)
			features.onsetClusters = Feature.YES;
			
		// Feature: Medial Codas
		if (rng.nextInt(8) < 5)
			features.medialCodas = Feature.YES;
	
		// Feature: Terminal codas
		roll = rng.nextInt(8);
		if (roll == 0)
			features.terminalCodas = Feature.REQUIRED;
		else if (roll < 5)
			features.terminalCodas = Feature.YES;
		
		// Feature: Coda clusters
		if ((features.medialCodas != Feature.NO || features.terminalCodas != Feature.NO) && rng.nextInt(2) < 1)
			features.codaClusters = Feature.YES;
		
		// Feature: Consonant gemination
		if (rng.nextInt(3) < 1)
			features.geminateConsonants = Feature.YES;
		
		// Feature: Vowel gemination
		if (rng.nextInt(4) < 1)
			features.geminateVowels = Feature.YES;
		
		// Feature: Diphthongs
		if (rng.nextInt(4) < 3)
			features.diphthongs = Feature.YES;
		
		// Feature: Hiatus
		roll = rng.nextInt(5);
		if (roll < 3)
			features.hiatus = Feature.RESTRICTED;
		else if (roll < 4)
			features.hiatus = Feature.UNRESTRICTED;
		
		System.out.println("FEATURES");
		System.out.println("Initial onsets:      " + features.initialOnsets);
		System.out.println("Onset clusters:      " + features.onsetClusters);
		System.out.println("Medial codas:        " + features.medialCodas);
		System.out.println("Terminal codas:      " + features.terminalCodas);
		System.out.println("Coda clusters:       " + features.codaClusters);
		System.out.println("Geminate consonants: " + features.geminateConsonants);	
		System.out.println("Geminate vowels:     " + features.geminateVowels);
		System.out.println("Diphthongs:          " + features.diphthongs);
		System.out.println("Hiatus:              " + features.hiatus);
		
	}
	
	private void determineClusterStatistics()
	{
		// Determine max lengths
		maxOnsetLength = maxNucleusLength = 1;
		maxCodaLength = 1;
		
		// Onsets
		if (features.onsetClusters == Feature.YES)
		{
			if (rng.nextInt(4) < 2)
				maxOnsetLength = 2;
			else
				maxOnsetLength = 3;
		}
		
		System.out.println("Max onset length: " + maxOnsetLength);
		
		if (features.onsetClusters == Feature.YES || features.codaClusters == Feature.YES)
		{
			baseClusterChance = rng.nextGaussian() * baseClusterChanceStdev + baseClusterChanceMean;
			System.out.println("Base cluster chance: " + baseClusterChance);
		}
		if (features.medialCodas == Feature.YES)
		{
			baseMedialCodaChance = rng.nextGaussian() * baseMedialCodaChanceStdev + baseMedialCodaChanceMean;
			System.out.println("Base medial coda chance: " + baseMedialCodaChance);
		}
		
		// Codas
		if (features.medialCodas == Feature.NO && features.terminalCodas == Feature.NO 
				/*&& features.geminateConsonants == Feature.NO*/)
		{
			maxCodaLength = 0;
		}
		else if (features.codaClusters == Feature.YES)
		{
			if (rng.nextInt(4) < 3)
				maxCodaLength = 2;
			else
				maxCodaLength = 3;
		}
		
		// Nuclei
		if (features.diphthongs == Feature.YES || features.geminateVowels == Feature.YES)
		{
			maxNucleusLength = 2;
			baseDiphthongChance = rng.nextGaussian() * baseDiphthongChanceStdev + baseDiphthongChanceMean;
		}
		
		// Determine weights and offsets
		if (features.onsetClusters == Feature.YES)
		{
			onsetClusterOffset = rng.nextGaussian() * 0.25 + 0.5;
		}

		if (features.diphthongs == Feature.YES || features.geminateVowels == Feature.YES)
		{
			diphthongOffset = rng.nextGaussian() * 0.25 + 0.5;
			geminateVowelOffset = rng.nextGaussian() * 0.25 + 0.5;
		}
		
		if (features.codaClusters == Feature.YES)
		{
			codaClusterOffset = rng.nextGaussian() * 0.25 + 0.5;
		}
	}

	/**
	 * Determine which phonetic Properties will be present in this language, how prominent they will be,
	 * and in what contexts. A Phoneme can be said to possess its own prominence rating equal to the sum of
	 * its Properties' prominence ratings' means. These ratings are used to determine the probability of
	 * its child syllable Constituents appearing in different contexts. 
	 * 
	 * Related clusterLeadProminence and clusterFollowProminence help determine how frequently a consonant will
	 * appear in a cluster preceeding or following (respectively) other phonemes.
	 * @since	1.0
	 */ 
	private void determineProminence()
	{
		// Determine which properties are represented
		consonantPropertiesRepresented = new boolean[ConsonantProperty.values().length];
		vowelPropertiesRepresented = new boolean[VowelProperty.values().length];
		
		for (int i = 0; i < ConsonantProperty.values().length; i++)
			if (rng.nextDouble() < ConsonantProperty.values()[i].getProbability())
				consonantPropertiesRepresented[i] = true;
		
		for (int i = 0; i < VowelProperty.values().length; i++)
			if (rng.nextDouble() < VowelProperty.values()[i].getProbability())
				vowelPropertiesRepresented[i] = true;
		
		/*
		 * Set these prominence ratings no matter what
		 */
		
		// Medial onsets
		baseConsonantRatings = new PhoneticRatings(this, true, basicProminenceStdev, basicProminenceMean);
		
		// Initial onsets
		initialOnsetRatings = new PhoneticRatings(this, baseConsonantRatings);
		initialOnsetRatings.disturb(0.5);
		
		// Medial nuclei
		baseVowelRatings = new PhoneticRatings(this, false, vowelProminenceStdev, vowelProminenceMean);
 
		// Root nuclei
		rootNucleusRatings = new PhoneticRatings(this, baseVowelRatings);
		rootNucleusRatings.disturb(0.5);
		rootNucleusRatings.offset(-0.25);
		
		/*
		 * Set these prominence ratings only if the corresponding feature is presenct
		 */
		if (features.initialOnsets != Feature.REQUIRED)
		{
			initialNucleusRatings = new PhoneticRatings(this, baseVowelRatings);
			initialNucleusRatings.disturb(0.5);
			initialNucleusRatings.offset(-0.10);
		}
		
		if (features.terminalCodas != Feature.REQUIRED)
		{
			terminalNucleusRatings = new PhoneticRatings(this, baseVowelRatings);
			terminalNucleusRatings.disturb(0.5);
			terminalNucleusRatings.offset(-0.25);
		}
			
		/*
		 * Set coda prominence values for consonant properties. 
		 * Coda prominence values are generated by "disturbing" base prominence values, that is, by adding a 
		 * randomly generated Gaussian term, so they are influenced by onset values but not beholden
		 * to them. The magnitude of the Gaussian term is determined by codaDisturbance, representing the
		 * proportion of prominenceStdev by which to scale the deviation.
		 */
		if (features.medialCodas != Feature.NO || features.terminalCodas != Feature.NO)
		{
			// Medial codas
			baseCodaRatings = new PhoneticRatings(this, true, basicCodaStdev, basicCodaMean);
			
			// Coda disturbance is the square of a uniformly distributed random number between 0 and 1
			codaDisturbance = Math.pow(rng.nextDouble(), 2);
			
			codaRatingOffset = rng.nextGaussian() * codaOffsetStdev + codaOffsetMean;
			codaRatingOffset = -Math.max(0, codaRatingOffset);
			
			baseCodaRatings.disturb(basicProminenceStdev * codaDisturbance);
			baseCodaRatings.offset(codaRatingOffset);
			
			// Set interlude lead/follow prominences
			if (features.medialCodas != Feature.NO)
			{
				bridgeLeadRatings =   new PhoneticRatings(this, true, bridgeLeadStdev, bridgeLeadMean);
				bridgeFollowRatings = new PhoneticRatings(this, true, bridgeFollowStdev, bridgeFollowMean);
			}
			
			if (features.terminalCodas != Feature.NO)
			{
				terminalCodaRatings = new PhoneticRatings(this, baseCodaRatings);
				terminalCodaRatings.disturb(0.5);
			}
		}
		
		
		if (features.onsetClusters == Feature.YES)
		{
			// Onset cluster lead/follow prominences
			onsetClusterLeadRatings   = new PhoneticRatings(this, true, clusterLeadStdev, clusterLeadMean);
			onsetClusterFollowRatings = new PhoneticRatings(this, true, clusterFollowStdev, clusterFollowMean);
		}

		if (features.geminateVowels == Feature.YES || features.diphthongs == Feature.YES)
		{
			// Diphthong (nucleus cluster) lead/follow prominences
			diphthongLeadRatings   = new PhoneticRatings(this, false, diphthongLeadStdev, diphthongLeadMean);
			diphthongFollowRatings = new PhoneticRatings(this, false, diphthongFollowStdev, diphthongFollowMean);
		}
		
		if (features.codaClusters == Feature.YES)
		{
			// Set coda lead/follow prominences
			codaClusterLeadRatings   = new PhoneticRatings(this, true, clusterLeadStdev, clusterLeadMean);
			codaClusterFollowRatings = new PhoneticRatings(this, true, clusterFollowStdev, clusterFollowMean);
		}

		if (features.hiatus != Feature.NO)
		{
			// Set hiatus ratings
			hiatusLeadRatings =   new PhoneticRatings(this, true, hiatusLeadStdev, hiatusLeadMean);
			hiatusFollowRatings = new PhoneticRatings(this, true, hiatusFollowStdev, hiatusFollowMean);
		}
		
		// Set miscellaneous phonotactic offsets
		onsetNgOffset   	  = Math.max(rng.nextGaussian() * onsetNgOffsetStdev + onsetNgOffsetMean, 0);
		onsetTlDlOffset 	  = Math.max(rng.nextGaussian() * onsetTlDlOffsetStdev + onsetTlDlOffsetMean, 0);
		codaGlottalStopOffset = Math.max(rng.nextGaussian() * codaGlottalStopOffsetStdev + codaGlottalStopOffsetMean, 0);
		nasalDissonanceOffset = Math.max(rng.nextGaussian() * nasalDissonanceOffsetStdev + nasalDissonanceOffsetMean, 0);
		unequalVoicingOffset  = Math.max(rng.nextGaussian() * unequalVoicingOffsetStdev + unequalVoicingOffsetMean, 0);
		
		
	}
	
	/**
	 * Decide which segments will be present in the language. Any phoneme all of whose constituent phonetic categories
	 * are present (i.e., have positive prominence) should be added. The same procedure is performed twice: once for
	 * consonants and one for vowels.
	 * @since	1.0
	 */
	private void selectSegments()
	{
		ArrayList<Phoneme> inv = new ArrayList<Phoneme>();
		
		// Make easy reference to consonant segment array
		ConsonantSegment[] consonants = ConsonantSegment.segments;
		ArrayList<ConsonantSegment> defective = new ArrayList<ConsonantSegment>();
		
		// Populate consonant inventory
		for (int i = 0; i < consonants.length; i++)
		{
			// Resolve to add the segment to the inventory by default.
			// If any of the segment's properties has 0 prominence (i.e., is absent from the language), immediately
			// decide not to add the segment.
			boolean add = true;
			
			for (int j = 0; j < consonants[i].properties.length; j++) 
				if (baseConsonantRatings.getRating(((ConsonantProperty) consonants[i].properties[j]).ordinal()) == 0)
				{
					add = false;
					j = consonants[i].properties.length;
				}
			
			if (add)
			{
				if (rng.nextDouble() > consonants[i].defectiveChance)
					inv.add(makeConsonantPhoneme(consonants[i]));
				else
					defective.add(consonants[i]);
			}		
		}
		
		consonantInventory = inv.toArray(new ConsonantPhoneme[0]);
		
		// If this language has no consonants, add 'P' to the inventory
		if (consonantInventory.length == 0)
		{
			for (int i = 0; i < ConsonantSegment.segments[0].properties.length; i++)
				baseConsonantRatings.setRating(ConsonantSegment.segments[0].properties[i].ordinal(), 1);
			
			consonantInventory = new ConsonantPhoneme[] { makeConsonantPhoneme(ConsonantSegment.segments[0]) };
		}
		
		// Mark phonotactic transition categories represented in this language's inventory
		consonantCategoriesRepresented = new boolean[Phonotactics.consonantCategories.size()];
		for (Phoneme p : inv)
			consonantCategoriesRepresented[p.segment.transitionCategory] = true;
		
		// Make easy reference to vowel segment array
		VowelSegment[] vowels = VowelSegment.segments;
		
		inv = new ArrayList<Phoneme>();
		
		// Populate vowel inventory in the same fashion as the consonant array
		for (int i = 0; i < vowels.length; i++)
		{
			boolean add = true;
			
			for (int j = 0; j < vowels[i].properties.length; j++)
				if (baseVowelRatings.getRating(((VowelProperty) vowels[i].properties[j]).ordinal()) == 0)
				{
					add = false;
					j = vowels[i].properties.length;
				}
			
			if (add)
			{
				inv.add(makeVowelPhoneme(VowelSegment.segments[i]));
				if (vowels[i].expression.equals(":"))
					longVowel = (VowelPhoneme) inv.get(inv.size() - 1);
			}
		}
		
		vowelInventory = inv.toArray(new VowelPhoneme[inv.size()]);
		
		// If this language has no vowels, add 'A' to the inventory
		if (vowelInventory.length == 0)
		{
			baseVowelRatings.setRating(VowelProperty.OPEN.ordinal(), 1);
			vowelInventory = new VowelPhoneme[] { makeVowelPhoneme(VowelSegment.segments[1]) };
		}
		
		// Mark phonotactic transition categories represented in this language's inventory
		vowelCategoriesRepresented = new boolean[Phonotactics.vowelCategories.size()];
		for (Phoneme p : inv)
			vowelCategoriesRepresented[p.segment.transitionCategory] = true;
	}
	
	/**
	 * First, this method determines which transitions are possible between different phonotactic categories,
	 * and therefore which Phoneme pairs might occur as a consonant cluster in this Phonology's onsets.
	 * Having decided this, the method invokes findAllOnsets() to populate the onset list.
	 * @since	1.0
	 */
	private void makeOnsets()
	{
		// transProb contains every combination of 2 phonotactic categories
		int[][] transProb = Phonotactics.onsetTransitions;
		validOnsetTransitions = new boolean[transProb.length][transProb[0].length];
		
		// Roll lead and follow probabilities for each phonotactic category
		double[] leadProbability = new double[transProb.length], followProbability = new double[transProb[0].length];
		for (int i = 0; i < leadProbability.length; i++)
			leadProbability[i] = rng.nextDouble();
		for (int i = 0; i < followProbability.length; i++)
			followProbability[i] = rng.nextDouble();
		
		
		/* Determine which transitions are possible between phonotactic categories.
		 * Every possible transition between categories has a chance of occurring, but those chances
		 * are not wholly independent from each other. Instead of rolling an independent random variable
		 * for each combination, we instead roll two for each category - one to indicate the chance of it
		 * leading in a cluster, the other the chance of following. These are both uniformly distributed
		 * random variables between 0 and 1. The roll for the inclusion of a given cluster is the product
		 * of the the first Phoneme's leadProbability and the second's followProbability. The cdf for the
		 * the product of these two random variables is f(z) = z - z * log z.
		 */
		for (int i = 0; i < transProb.length; i++)
			if (consonantCategoriesRepresented[i])
				for (int j = 0; j < transProb[0].length; j++)
					if (consonantCategoriesRepresented[j])
					{
						// Chance of representation ~= f(.4 x 15^(commonness - 3))
						// 3 -> .559, 2 -> .069, 1 -> .007
						double p = 0.4 * Math.pow(15, transProb[i][j] - 3);
						
						if (leadProbability[i] * followProbability[j] < p)
							validOnsetTransitions[i][j] = true; 
					}
	
		// Add lists of constituents to library object
		medialOnsets = new ConstituentLibrary("main", maxOnsetLength, ConstituentType.ONSET, ConstituentLocation.MEDIAL);
		
		generateOnsets(medialOnsets);
		
		medialOnsets.removeUnusedMembers();
		medialOnsets.normalizeAll();
		medialOnsets.sortAll();
		
		initialOnsets = new ConstituentLibrary("main", maxOnsetLength, ConstituentType.ONSET, ConstituentLocation.INITIAL);
		generateOnsets(initialOnsets);
		initialOnsets.removeUnusedMembers();
//		initialOnsets.exaggerate(2);
		initialOnsets.normalizeAll();
		initialOnsets.sortAll();
		
		// Add clusters 
		if (features.onsetClusters == Feature.YES)
		{
			generateOnsetClusterLists();
		}
	}
	
	/**
	 * First, this method determines which transitions are possible between different phonotactic categories,
	 * and therefore which Phoneme pairs might occur as diphthongs in this Phonology. Having decided this, 
	 * the method invokes findAllNuclei() to populate the nucleus list.
	 * 
	 * The math motivating the selection of phonotactic category transitions is explained in makeOnsets() and
	 * will not be restated here.
	 * 
	 * @since	1.0
	 */
	private void makeNuclei()
	{
		int[][] transProb = Phonotactics.nucleusTransitions;
		validNucleusTransitions = new boolean[transProb.length][transProb[0].length];
		
		// Roll lead and follow probabilities for each phonotactic category
		double[] leadProbability = new double[transProb.length], followProbability = new double[transProb[0].length];
		for (int i = 0; i < leadProbability.length; i++)
			leadProbability[i] = rng.nextDouble();
		for (int i = 0; i < followProbability.length; i++)
			followProbability[i] = rng.nextDouble();
		
		// Determine which transitions are possible between phonotactic categories
		for (int i = 0; i < transProb.length; i++)
		{
			if (vowelCategoriesRepresented[i])
				for (int j = 0; j < transProb[0].length; j++)
					if (vowelCategoriesRepresented[j] && transProb[i][j] > 0)
					{
						// Chance of representation ~= f(.4 x 15^(commonness - 3))
						// 3 -> .559, 2 -> .069, 1 -> .007
						double p = 0.4 * Math.pow(15, transProb[i][j] - 3);
						
						if (leadProbability[i] * followProbability[j] < p)
							validNucleusTransitions[i][j] = true; 
					}
		}
		
		// Populate medial nucleus library
		medialNuclei = new ConstituentLibrary("main", maxNucleusLength, ConstituentType.NUCLEUS, ConstituentLocation.MEDIAL);
		generateNuclei(medialNuclei);
		medialNuclei.removeUnusedMembers();
		medialNuclei.normalizeAll();
		medialNuclei.sortAll();
		
		// Populate initial nucleus library
		initialNuclei = new ConstituentLibrary("main", maxNucleusLength, ConstituentType.NUCLEUS, ConstituentLocation.INITIAL);
		if (features.initialOnsets != Feature.REQUIRED)
		{
			generateNuclei(initialNuclei);
			initialNuclei.removeUnusedMembers();
			medialNuclei.exaggerate(2);
			initialNuclei.normalizeAll();
			initialNuclei.sortAll();
		}
		
		// Populate initial nucleus library
		terminalNuclei = new ConstituentLibrary("main", maxNucleusLength, ConstituentType.NUCLEUS, ConstituentLocation.TERMINAL);
		if (features.terminalCodas != Feature.REQUIRED)
		{
			generateNuclei(terminalNuclei);
			terminalNuclei.removeUnusedMembers();
			terminalNuclei.exaggerate(2);
			terminalNuclei.normalizeAll();
			terminalNuclei.sortAll();
		}
		
		// Populate initial nucleus library
		rootNuclei = new ConstituentLibrary("main", maxNucleusLength, ConstituentType.NUCLEUS, ConstituentLocation.ROOT);
		generateNuclei(rootNuclei);
		rootNuclei.removeUnusedMembers();
		rootNuclei.normalizeAll();
		rootNuclei.sortAll();
		
		// Add clusters
		if (features.diphthongs == Feature.YES || features.geminateVowels == Feature.YES)
			generateNucleusClusterLists();
	}

	/**
	 * First, this method determines which transitions are possible between different phonotactic categories,
	 * and therefore which Phoneme pairs might occur as consonant clusters in this Phonology's codas. Having
	 * decided this, the method invokes findAllCodas() to populate the nucleus list.
	 * 
	 * The math motivating the selection of phonotactic category transitions is explained in makeOnsets() and
	 * will not be restated here.
	 * 
	 * @since	1.0
	 */
	private void makeCodas()
	{
		int[][] transProb = Phonotactics.codaTransitions;
		validCodaTransitions = new boolean[transProb.length][transProb[0].length];
		
		// Roll lead and follow probabilities for each phonotactic category
		double[] leadProbability = new double[transProb.length], followProbability = new double[transProb[0].length];
		for (int i = 0; i < leadProbability.length; i++)
			leadProbability[i] = rng.nextDouble();
		for (int i = 0; i < followProbability.length; i++)
			followProbability[i] = rng.nextDouble();

		// Determine which transitions are possible between phonotactic categories
		for (int i = 0; i < transProb.length; i++)
			if (consonantCategoriesRepresented[i])
				for (int j = 0; j < transProb[0].length; j++)
					if (consonantCategoriesRepresented[j] && transProb[i][j] > 0)
					{
						// Chance of representation ~= f(.4 x 15^(commonness - 3))
						// 3 -> .559, 2 -> .069, 1 -> .007
						double p = 0.4 * Math.pow(15, transProb[i][j] - 3);
						
						if (leadProbability[i] * followProbability[j] < p)
							validCodaTransitions[i][j] = true; 
					}
	
		if (features.medialCodas != Feature.NO)
		{
			// Initialize coda library
			medialCodas = new ConstituentLibrary("main", maxCodaLength, ConstituentType.CODA, ConstituentLocation.MEDIAL);
			
			// Populate coda list
			generateCodas(medialCodas);

			// Remove unused codas
			medialCodas.removeUnusedMembers();
			
			// Note that unlike makeOnsets and makeNuclei, in makeCodas We delay the normalization of coda values until after
			// makeInterludes, as that method makes use of codas (in particular, that may be cut from the master list.
			if (medialCodas.size() > 0)
			{
				makeBridge();
			}
		}
		
		
		if (features.terminalCodas != Feature.NO)
		{
			terminalCodas = new ConstituentLibrary("main", maxCodaLength, ConstituentType.CODA, ConstituentLocation.TERMINAL);
			generateCodas(terminalCodas);
			terminalCodas.removeUnusedMembers();
			terminalCodas.exaggerate(2);
			terminalCodas.normalizeAll();
			terminalCodas.sortAll();
			terminalCodas.printMembers();
		}
		
		// Generate coda clusters, if applicable
		if (features.codaClusters == Feature.YES)
			generateCodaClusterLists();
	}
	
	/**
	 * This method decides what vowel-vowel transitions are allowed in the case of an empty interlude. The process
	 * is analogous to that used by the makeOnsets/Nuclei/Codas methods, except that transitions occur directly
	 * between vowels instead of phonotactic categories, if a transition is found, it is immediately added to the
	 * leading vowel's interlude list.
	 * 
	 * @since	1.0
	 */
	private void makeHiatus()
	{
		if (features.hiatus != Feature.NO)
		{
			// Create follower lists for all vowels in inventory
			for (VowelPhoneme vp : vowelInventory)
			{
				vp.createFollowerLists(maxNucleusLength);
			}
			
			hiatusProminenceOffset = rng.nextGaussian() * hiatusOffsetStdev;
			baseHiatusChance = rng.nextGaussian() * baseHiatusChanceStdev + baseHiatusChanceMean;

			// Roll lead and follow probabilities.
			// -1 to count ignores the 'lengthener' segment
			double[] leadProbabilities = new double[VowelSegment.count() - 1], followProbabilities = new double[VowelSegment.count() - 1];
			for (int i = 0; i < leadProbabilities.length; i++)
			{
				leadProbabilities[i] = rng.nextDouble();
				followProbabilities[i] = rng.nextDouble();
			}
			
			// Medial hiatus
			for (VowelPhoneme v1 : vowelInventory)
			{
				v1.makeHiatus(medialNuclei, leadProbabilities, followProbabilities, hiatusProminenceOffset);
				v1.setHiatusChance(baseHiatusChance * v1.getMedialFollowers().size() / (medialOnsets.size() + v1.getMedialFollowers().size()));
				
				v1.makeHiatus(terminalNuclei, leadProbabilities, followProbabilities, hiatusProminenceOffset);
				v1.makeHiatus(rootNuclei, leadProbabilities, followProbabilities, hiatusProminenceOffset);
			}
		}
		else
		{
			baseHiatusChance = 0;
			hiatusProminenceOffset = 0;
		}
	}
	
	/**
	 * This method determines which onsets may follow a coda. Again, the process is based on that of
	 * makeOnsets/Nuclei/Codas; though like these method it considers transitions between phonotactic
	 * categories, it operates on individual Phonemes and adds connecting onsets directly to the coda's
	 * interlude list.  
	 * 
	 * @since	1.0
	 */
	private void makeBridge()
	{
		// Create follower lists for all consonants in inventory
		for (ConsonantPhoneme cp : consonantInventory)
		{
			cp.createBridgePrecedersList(maxCodaLength);
		}
		
		interludeOffset = rng.nextGaussian() * interludeOffsetStdev;
		
		int[][] transProb = Phonotactics.interludeTransitions;
		
		// Roll lead and follow probabilities for each phonotactic category
		double[] leadProbability   = new double[transProb.length],
				 followProbability = new double[transProb[0].length];
		for (int i = 0; i < leadProbability.length; i++)
			leadProbability[i] = rng.nextDouble();
		for (int i = 0; i < followProbability.length; i++)
			followProbability[i] = rng.nextDouble();
		
		// Generate lists of interlude transitions for phonemes
		for (int i = 0; i < medialCodas.size(); i++)
		{
			ConsonantPhoneme coda = (ConsonantPhoneme) medialCodas.get(i).getContent();
			for (int j = 0; j < medialOnsets.size(); j++)
			{
				ConsonantPhoneme onset = (ConsonantPhoneme) medialOnsets.get(j).getContent();
				
				
				// Chance of representation ~= f(.4 x 15^(commonness - 3))
				// 3 -> .559, 2 -> .069, 1 -> .007
				double probability = 0.4 * 
						Math.pow(15, transProb[coda.segment.transitionCategory][onset.segment.transitionCategory] - 3)
										+ interludeOffset;
				
				if (leadProbability[coda.segment.transitionCategory] * followProbability[onset.segment.transitionCategory] < probability)
					addBridge(coda, onset);
				coda.setValidInPosition(ConstituentLocation.MEDIAL, ConstituentType.CODA);
			}
		}
		
		// Remove codas with no interludes
		medialCodas.removeInvalidMembers();
		medialCodas.sortAll();
		
		for (Constituent c : medialOnsets.getMembers())
		{
			ConsonantPhoneme coda = (ConsonantPhoneme) c.getContent();
			coda.normalizeAndSortFollowers();
			coda.calculateMedialCodaChance(baseMedialCodaChance);
			coda.getBridgePreceders().printMembers();
		}
			
		
	}
		

	
		/**
		 * Adds a SyllableSegment to this Phoneme's interlude inventory. If this Phoneme represents a consonant,
		 * the SyllableSegment represents an onset that may follow when this Phoneme is used as a coda.
		 * @param	c	A coda or nucleus that may follow this Phoneme
		 * @since	1.0
		 */
		protected void addBridge(ConsonantPhoneme codaTail, ConsonantPhoneme onsetHead)
		{
			// If interludeLeadProminence <= 0, this phoneme does not lead in interludes/hiatus
			if (codaTail.getInterludeLeadProminence() <= 0)
				return;
			
			// Calculate interlude's probability.
			// Base probability equals sum of following segment's interludeFollow and onsetInitial prominences
			double probability = onsetHead.getInterludeFollowProminence();
			probability += onsetHead.getMedialProminence() - 1;
			probability += codaTail.getInterludeLeadProminence() - 1;
			
			System.out.printf("%s to %s: %.3f + %.3f + %.3f - 2\n", codaTail, onsetHead, onsetHead.getInterludeFollowProminence(),
								onsetHead.getMedialProminence(), codaTail.getInterludeLeadProminence());
			
			// Apply nasal dissonance inhibitor, if relevant
			if (Phoneme.isDissonantNasalCluster(codaTail, onsetHead))
				probability -= nasalDissonanceOffset;
			
			// If probability is positive, add this interlude
			if (probability > 0)
			{
				onsetHead.getBridgePreceders().add(new Constituent(ConstituentType.CODA, codaTail, probability));
			}
			
			// Print interlude statistics
//			System.out.printf("%.3f (%.3f + %,3f)", probability, p.interludeFollowProminence, p.onsetInitialProminence);
		}

	/**
	 * Sets base chances for medial onsets and medial/terminal codas. These values are used
	 * in MorphemeAssembly to determine the weights of transitions between nodes.
	 * 
	 * @since	1.0
	 */
	private void setBaseChances()
	{
		// Chance of a name starting with a vowel
		if (features.initialOnsets != Feature.REQUIRED)
			baseEmptyInitialOnsetChance = Math.max(rng.nextGaussian() * emptyInitialOnsetProminenceStdev + emptyInitialOnsetProminenceMean, 0);
		else
			baseEmptyInitialOnsetChance = 0;
		
		
	
		if (features.terminalCodas == Feature.NO)
			baseTerminalCodaChance = 0;
		else if (features.terminalCodas == Feature.REQUIRED)
		{
			baseTerminalCodaChance = 1;
			closedFinalSyllableChance = 1;
			if (features.hiatus != Feature.NO)
				for (VowelPhoneme vp : vowelInventory)
					if (!vp.segment.expression.equals(":") && vp.getTerminalFollowers().size() > 0)
						vp.setClosedFinalSyllableChance(1);
		}
		else
		{
			baseTerminalCodaChance = rng.nextGaussian() * baseTerminalCodaChanceStdev + baseTerminalCodaChanceMean;
			baseTerminalCodaChance = Math.max(Math.min(baseTerminalCodaChance, 1), 0); // Clamp to [0, 1]
			
			closedFinalSyllableChance = getTerminalCodaChance(medialNuclei, terminalNuclei);
			System.out.println("Closed final syllable chance = " + closedFinalSyllableChance + " (Base: " + baseTerminalCodaChance + ")");
			
			if (features.hiatus != Feature.NO)
				for (VowelPhoneme vp : vowelInventory)
					if (!vp.segment.expression.equals(":"))
						vp.setClosedFinalSyllableChance(getTerminalCodaChance(vp.getMedialFollowers(), vp.getTerminalFollowers()));
			
		}
		
//		baseSuffixOnsetChance = Math.min(Math.max(rng.nextDouble() * 2 - 0.5, 0), 1);
		baseSuffixOnsetChance = 0;
	}
	
	private double getTerminalCodaChance(ConstituentLibrary medialLib, ConstituentLibrary terminalLib)
	{
		if ((medialLib == null || medialLib.size() == 0) && (terminalLib == null || terminalLib.size() == 0))
			return -1;
		
		double pConsonantTermination = baseTerminalCodaChance;
		double pVowelTermination = 1 - pConsonantTermination;
		
		int qtyCodas= (features.terminalCodas != Feature.NO) ? terminalCodas.size() : 0;
		int qtyNuclei = (features.terminalCodas != Feature.REQUIRED) ? terminalLib.size() : 0;
		
		// Scale pConsonantTermination toward 0 or 1 according to the proportions of terminal consonants to terminal nuclei
		if (qtyCodas < qtyNuclei)
			pConsonantTermination *= qtyCodas / qtyNuclei;
		else if (qtyCodas > qtyNuclei)
			pConsonantTermination = 1 - pVowelTermination * qtyNuclei / qtyCodas;
		
		return pConsonantTermination;
	}
	
//	private void makeSuffixes()
//	{
//		suffixes = new SuffixLibrary(this);
//		
//		
//		int size = (int) Math.pow((rng.nextDouble() * 6), 2) + 1;
//		Name[] names = new Name[size];
//		
//		for(int i = 0; i < names.length; i++)
//    		names[i] = assembly.makeSuffix();
//		for(int i = 0; i < names.length; i++)
//			suffixes.addName(names[i], rng.nextDouble());
//	
//		suffixes.addName(Name.NEW_SUFFIX, rng.nextDouble());
//		
//		System.out.println("Exaggeration factor: " + Math.sqrt(suffixes.size()));
////		suffixes.exaggerate(Math.sqrt(suffixes.size()));
//		suffixes.sort();
//		suffixes.zipfScale();
//		suffixes.normalize();
//		
//		combinationRules = new CombinationRules(this);
//	}

	private ConsonantPhoneme makeConsonantPhoneme(ConsonantSegment cs)
	{
		// Assign default prominence values
		double medialProminence				= 1;
		double wordInitialProminence	 	= 1;
		double medialCodaProminence			= 1;
		double terminalCodaProminence		= 1;
		
		double onsetClusterLeadProminence	= 1;
		double onsetClusterFollowProminence = 1;
		double codaClusterLeadProminence    = 1;
		double codaClusterFollowProminence  = 1;
		double interludeLeadProminence  	= 1;
		double interludeFollowProminence	= 1;
		
		// Apply offsets
		if (cs.expression.equals("ng"))
		{
			medialProminence   		  -= onsetNgOffset;
			wordInitialProminence	  -= onsetNgOffset;
			interludeFollowProminence -= onsetNgOffset;
		}
		else if (cs.expression.equals("'"))
		{
			medialCodaProminence		-= codaGlottalStopOffset;
			terminalCodaProminence		-= codaGlottalStopOffset;
			codaClusterLeadProminence	-= codaGlottalStopOffset;
			codaClusterFollowProminence -= codaGlottalStopOffset;
		}
		
		/* Calculate prominence values. 
		 * Math note: initialProminence is the result of combining all the prominence values of the
		 * segment's properties, with mean 1. The deviance of each prominence is scaled by the root of
		 * the number of the segment's properties; this ensures that all intialProminence values are
		 * distributed, in effect, with the same standard deviation, regardless of how many values are
		 * added to make it (normally, adding random variables increases the stdev of the sum). The
		 * same is true of the cluster prominence values as well.
		 */
		for (ConsonantProperty s : cs.properties)
		{
			// Initial properties
			double deviance = baseConsonantRatings.getRating(s.ordinal()) - 1;
			deviance /= Math.sqrt(cs.properties.length);
			medialProminence += deviance;
			
			deviance = initialOnsetRatings.getRating(s.ordinal()) - 1;
			deviance /= Math.sqrt(cs.properties.length);
			wordInitialProminence += deviance;
			
			if (maxCodaLength > 0)
			{
				deviance = baseCodaRatings.getRating(s.ordinal()) - 1;
				deviance /= Math.sqrt(cs.properties.length);
				medialCodaProminence += deviance;
				
				if (features.terminalCodas != Feature.NO)
				{
					deviance = terminalCodaRatings.getRating(s.ordinal()) - 1;
					deviance /= Math.sqrt(cs.properties.length);
					terminalCodaProminence += deviance;
				}
				else
					terminalCodaProminence = 0;
				
			}
			
			// Onset cluster properties
			if (features.onsetClusters != Feature.NO)
			{
				deviance = onsetClusterLeadRatings.getRating(s.ordinal()) - 1;
				deviance /= Math.sqrt(cs.properties.length);
				onsetClusterLeadProminence += deviance;
				
				deviance = onsetClusterFollowRatings.getRating(s.ordinal()) - 1;
				deviance /= Math.sqrt(cs.properties.length);
				onsetClusterFollowProminence += deviance;
			}
			else
			{
				onsetClusterLeadProminence = 0;
				onsetClusterFollowProminence = 0;
			}
			
			// Coda cluster properties
			if (features.medialCodas != Feature.NO || features.terminalCodas != Feature.NO)
			{
				
				if (features.codaClusters != Feature.NO)
				{
					deviance = codaClusterLeadRatings.getRating(s.ordinal()) - 1;
					deviance /= Math.sqrt(cs.properties.length);
					codaClusterLeadProminence += deviance;
					
					deviance = codaClusterFollowRatings.getRating(s.ordinal()) - 1;
					deviance /= Math.sqrt(cs.properties.length);
					codaClusterFollowProminence += deviance;
				}
				
				if (features.medialCodas != Feature.NO)
				{
					deviance = bridgeLeadRatings.getRating(s.ordinal()) - 1;
					deviance /= Math.sqrt(cs.properties.length);
					interludeLeadProminence += deviance;
					
					deviance = bridgeFollowRatings.getRating(s.ordinal()) - 1;
					deviance /= Math.sqrt(cs.properties.length);
					interludeFollowProminence += deviance;
				}
				else
					interludeLeadProminence = interludeFollowProminence = 0;
			}
			else
				codaClusterLeadProminence = codaClusterFollowProminence = 0;
			
		}
		
		return new ConsonantPhoneme(cs, medialProminence, wordInitialProminence, medialCodaProminence, terminalCodaProminence, 
									onsetClusterLeadProminence, onsetClusterFollowProminence, codaClusterLeadProminence, codaClusterFollowProminence,
									interludeLeadProminence, interludeFollowProminence, maxOnsetLength, maxCodaLength);
	}
	
	private VowelPhoneme makeVowelPhoneme(VowelSegment vowel)
	{
		// Assign initial prominence values
		double medialProminence				= 1;	// this functions as the nucleus initial prominence here
		double wordInitialProminence		= 1;
		double terminalProminence			= 1;
		double rootProminence				= 1;
		double nucleusLeadProminence 		= 1;
		double nucleusFollowProminence 		= 1;
		double interludeLeadProminence  	= 1;
		double interludeFollowProminence 	= 1;
		
		
		
		// Apply offsets
		if (vowel.expression.equals(":"))
		{
			medialProminence = Integer.MIN_VALUE;
		}
		
		// Calculate prominence values
		for (VowelProperty s : vowel.properties)
		{
			double deviance = baseVowelRatings.getRating(s.ordinal()) - 1;
			deviance /= Math.sqrt(vowel.properties.length);
			medialProminence += deviance;
			
			
			if (features.initialOnsets != Feature.REQUIRED)
			{
				deviance = initialNucleusRatings.getRating(s.ordinal()) - 1;
				deviance /= Math.sqrt(vowel.properties.length);
				wordInitialProminence += deviance;
			}
			else
				wordInitialProminence = 0;
			
			
			if (features.terminalCodas != Feature.REQUIRED)
			{
				deviance = terminalNucleusRatings.getRating(s.ordinal()) - 1;
				deviance /= Math.sqrt(vowel.properties.length);
				terminalProminence += deviance;
			}
			else
				terminalProminence = 0;
			
			deviance = rootNucleusRatings.getRating(s.ordinal()) - 1;
			deviance /= Math.sqrt(vowel.properties.length);
			rootProminence += deviance;
			
			if (features.hiatus != Feature.NO)
			{
				deviance = hiatusLeadRatings.getRating(s.ordinal()) - 1;
				deviance /= Math.sqrt(vowel.properties.length);
				interludeLeadProminence += deviance;
				
				deviance = hiatusFollowRatings.getRating(s.ordinal()) - 1;
				deviance /= Math.sqrt(vowel.properties.length);
				interludeFollowProminence += deviance;
			}
			else
			{
				interludeLeadProminence = 0;
				interludeFollowProminence = 0;
			}
			
			if (maxNucleusLength > 1)
			{
				deviance = diphthongLeadRatings.getRating(s.ordinal()) - 1;
				deviance /= Math.sqrt(vowel.properties.length);
				nucleusLeadProminence += deviance;
				
				deviance = diphthongFollowRatings.getRating(s.ordinal()) - 1;
				deviance /= Math.sqrt(vowel.properties.length);
				nucleusFollowProminence += deviance;	
			}
			else
			{
				nucleusLeadProminence = 0;
				nucleusFollowProminence = 0;
			}
		}
		
		return new VowelPhoneme(vowel, medialProminence, wordInitialProminence, terminalProminence, rootProminence, nucleusLeadProminence,
								nucleusFollowProminence, interludeLeadProminence, interludeFollowProminence, maxNucleusLength);
	}
	
	/**
	 * Generates onset inventories by calling the recursive function generateMedialOnsets for each
	 * phoneme on the consonant inventory.
	 * @since	1.2
	 */
	private void generateOnsets(ConstituentLibrary lib)
	{
		for (ConsonantPhoneme onset : consonantInventory)
		{
			double onsetProminence;
			
			// Start by adding the current phoneme.
			// To do this, its prominence (unnormalized probability) must be calculated.
			
			if (lib.getLocation() == ConstituentLocation.INITIAL)
				onsetProminence = onset.getInitialProminence();
			else
				onsetProminence = onset.getMedialProminence();
		
			// Add the current onset to the appropriate onset inventory
			Constituent c = new Constituent(ConstituentType.ONSET, onset, onsetProminence);
			lib.add(c);
		}
	}
	
	private void generateOnsetClusterLists()
	{
		for (ConsonantPhoneme onset : consonantInventory)
		{
			// If clusters are allowed, add them to the onset followers list
			if (features.onsetClusters != Feature.NO)
			{
				// Otherwise, consider what additions to this cluster might be possible
				int ptCat = onset.segment.transitionCategory; // get phonotactic transition category of the latest phoneme
				
				// For each phonotactic category to which the current phoneme might transition...
				for (int i = 0; i < validOnsetTransitions[ptCat].length; i++)
					if (validOnsetTransitions[ptCat][i])
					{
						// ... consider every member segment.
						for (int nextSound : Phonotactics.consonantCategories.get(i))
						{
							// If this Phonology has that segment, then create a new cluster by appending it to the current,
							// and recurse on it.
							for (int j = 0; j < consonantInventory.length; j++)
							{
								ConsonantPhoneme follower = consonantInventory[j];
							
								if (follower.segment.getID() == nextSound)
								{
									// Calculate follower prominence
									double followerProminence = onset.onsetClusterLeadProminence 
													  + follower.onsetClusterFollowProminence
													  - onsetClusterOffset
													  - 1;
												  	
									// Offset for tl/dl clusters
									if (onset.segment.properties[0] == ConsonantProperty.PLOSIVE &&
										onset.segment.properties[1] == ConsonantProperty.ALVEOLAR &&
										follower.segment.expression.equals("l"))
									{
										followerProminence -= onsetTlDlOffset;
									}
									
									// Add follower to leader's onset-context follower inventory
									onset.getOnsetFollowers().add(new Constituent(ConstituentType.ONSET, consonantInventory[j], followerProminence));
								}
							}
						}
					}
				
				// Set cluster chance
				onset.getOnsetFollowers().removeUnusedMembers();
				onset.getOnsetFollowers().normalizeAll();
				onset.getOnsetFollowers().sortAll();
				onset.getOnsetFollowers().setClusterChance(baseClusterChance);
				onset.getOnsetFollowers().setClusterEntropy(maxOnsetLength);
			}
		}
	}
	
	private void generateNuclei(ConstituentLibrary lib)
	{
		for (VowelPhoneme nucleus : vowelInventory)
		{
			// Do not allow nuclei beginning with a vowel lengthener
			if (nucleus.segment.expression.equals(":"))
				return;
			
			// Start by adding the current phoneme.
			// To do this, its prominence (unnormalized probability) must be calculated.
			// For simple nuclei, the prominence is merely equal to its sole phoneme's onset initial prominence (we're talking
			// about nuclei here, but the variable does double duty).
			double nucleusProminence;
			
			switch (lib.getLocation())
			{
				case INITIAL:
					nucleusProminence = nucleus.getInitialProminence();
					break;
				case MEDIAL:
					nucleusProminence = nucleus.getMedialProminence();
					break;
				case TERMINAL:
					nucleusProminence = nucleus.terminalProminence;
					break;
				case ROOT:
					nucleusProminence = nucleus.rootProminence;
					break;
				default:
					return;
			}

			// Add this nucleus to the appropriate nucleus inventory
			Constituent c = new Constituent(ConstituentType.NUCLEUS, nucleus, nucleusProminence);
			lib.add(c);
		}
	}
	
	private void generateNucleusClusterLists()
	{
		for (VowelPhoneme nucleus : vowelInventory)
		{
			// Otherwise, consider what additions to this diphthong might be possible
			int ptCat = nucleus.segment.transitionCategory; // get phonotactic transition category of the latest phoneme
			
			// For each phonotactic category to which the current phoneme might transition...
			for (int i = 0; i < validNucleusTransitions[ptCat].length; i++)
				if (validNucleusTransitions[ptCat][i])
				{
					// ... consider every member segment.
					for (int nextSound : Phonotactics.vowelCategories.get(i))
					{
						// If this Phonology has that segment, then create a new cluster by appending it to the current,
						// and recurse on it.
						for (int j = 0; j < vowelInventory.length; j++)
						{
							VowelPhoneme follower = vowelInventory[j];
							if (vowelInventory[j].segment.getID() == nextSound)
							{
								// Calculate follower prominence
								double followerProminence = nucleus.nucleusLeadProminence 
												  		  + follower.nucleusFollowProminence 
												  		  - diphthongOffset
												  		  - 1;
								
								// Add follower to leader's onset-context follower inventory
								nucleus.getNucleusFollowers().add(new Constituent(ConstituentType.NUCLEUS, vowelInventory[j], followerProminence));
								
								j = vowelInventory.length;	// Segment found; stop searching
							}
						}
					}
				}
			
			// Set diphthong chance
			nucleus.getNucleusFollowers().removeUnusedMembers();
			nucleus.getNucleusFollowers().normalizeAll();
			nucleus.getNucleusFollowers().sortAll();
			nucleus.getNucleusFollowers().setClusterChance(baseDiphthongChance);
			nucleus.getNucleusFollowers().setClusterEntropy(maxNucleusLength);

		}
	}
	
	private void generateCodas(ConstituentLibrary lib)
	{
		for (ConsonantPhoneme coda : consonantInventory)
		{
			// Start by adding the current phoneme.
			// To do this, its prominence (unnormalized probability) must be calculated.
			// For simple codas, the prominence is merely equal to its sole phoneme's codaInitialProminence.
			double codaProminence;
			
			if (lib.getLocation() == ConstituentLocation.TERMINAL)
				codaProminence = coda.terminalCodaProminence;
			else
				codaProminence = coda.medialCodaProminence;
			
			// Add the current coda to the appropriate coda inventory
			Constituent c = new Constituent(ConstituentType.CODA, coda, codaProminence);
			lib.add(c);
		}
	}
	
	private void generateCodaClusterLists()
	{
		// Generate cluster lists for each consonant
		for (ConsonantPhoneme coda : consonantInventory)
		{
			// Otherwise, consider how this cluster might continue
			int ptCat = coda.segment.transitionCategory; // get phonotactic transition category of the latest phoneme
			
			// For each phonotactic category to which the current phoneme might transition...
			for (int i = 0; i < validCodaTransitions.length; i++)
			{
				if (validCodaTransitions[ptCat][i])
				{
					// ... consider every member segment.
					for (int nextSound : Phonotactics.consonantCategories.get(i))
					{
						// If this Phonology has that segment, then create a new cluster by appending it to the current,
						// and recurse on it.
						for (int j = 0; j < consonantInventory.length; j++)
						{
							ConsonantPhoneme follower = consonantInventory[j];
							if (follower.segment.getID() == nextSound)
							{
								double followerProminence = coda.codaClusterLeadProminence
														  + follower.codaClusterFollowProminence
														  - codaClusterOffset
														  - 1;
							
								// Penalize for dissimilar nasal-plosive clusters
								if (Phoneme.isDissonantNasalCluster(coda, follower))
									followerProminence -= nasalDissonanceOffset;

								// Add coda to follower's coda-context preceder inventory
								if (followerProminence > 0)
									follower.getCodaPreceders().add(new Constituent(ConstituentType.CODA, coda, followerProminence));	
								
								j = consonantInventory.length;	// Segment found; stop searching
							}
						}
					}
				}
			}
		}
	
		// Normalize, sort, and set clustering chances
		for (ConsonantPhoneme coda : consonantInventory)
		{
			coda.getCodaPreceders().removeUnusedMembers();
			coda.getCodaPreceders().normalizeAll();
			coda.getCodaPreceders().sortAll();
			coda.getCodaPreceders().setClusterChance(baseClusterChance);
			coda.getCodaPreceders().setClusterEntropy(maxCodaLength);
		}
	}

	private void makeRoots()
	{
		roots = new MorphemeLibrary(false);
		
		for (int i = 0; i < 240; i++)
			roots.addMorpheme(makeRoot());
		
		roots.sort();
		roots.exaggerate(2);
		roots.normalize();
		roots.printMembers();
	}
	
	/**
	 * Generates and returns a random name from this Phonology.
	 * @since	1.0
	 */
	public Root makeRoot()
	{
		return assembly.makeBoundRoot();
	}
	
	public Suffix makeSuffix(double icTarget)
	{
		return assembly.makeSuffix(icTarget);
	}
	
	public Name makeName(NounClass nc)
	{
		Name name = new Name();
		
		Root root = (Root) roots.pick();
		Suffix suffix = nc.pickSuffix();
		
		name.addRoot(root);
		name.addSuffix(suffix);
		
		return name;
	}
	
	/**
	 * Prints various data about the current Phonology in great depth, including the contents of inventories,
	 * the statistics of the Phonology's stress system, and the chances of light and heavy rimes in weak and
	 * strong positions.
	 * @since	1.0
	 */
	public void printPhonology()
	{
		// Print inventories
		printInventory(medialOnsets.getMembers());
		printInventory(medialCodas.getMembers());
		printInventory(medialNuclei.getMembers());
	}
	
	/**
	 * Print every syllable segment in a given ArrayList
	 * @param	list	The list to be printed
	 * @since	1.0
	 */
	public void printInventory(ArrayList<Constituent> list)
	{
		if (list.size() == 0)
			return;
	
		for (Constituent c : list)
			System.out.printf("%s\t%.3f\n", c, (c.getProbability() / 1));
		
		System.out.println();
	}
	
	public void printHiatus()
	{
		for (VowelPhoneme v : vowelInventory)
		{
			v.printHiatus();
		}
	}
	
	/**
	 * Return an array containing linguistic data about the Phonology. Each array item represents a different
	 * set of information:
	 * 
	 * 0. Medial and terminal syllable structure
	 * 1. Consonant inventory
	 * 2. Vowel inventory
	 * 
	 * @return	An assortment of linguistic data about this Phonology	
	 * @since	1.1.2
	 */
	public LanguageData getLanguageData()
	{
		return new LanguageData(this);
	}
	
	public void compareOnsets()
	{
//		for (int i = 1; i <= Math.max(maxOnsetLength, maxCodaLength); i++)
//		{
//			ArrayList<Constituent> list = new ArrayList<Constituent>()
//			{	
//				public boolean add(Constituent c)
//				{
//					Iterator<Constituent> itr = this.iterator();
//					while (itr.hasNext())
//					{
//						Constituent next = itr.next();
//						if (c.sameSequence(next))
//							return false;
//					}
//					super.add(c);
//					return true;
//				}
//			};
//			
//			// Make combined set
//			ConstituentLibrary[] libs = new ConstituentLibrary[] { medialOnsets, initialOnsets, medialCodas,
//																	terminalCodas };
//			
//			for (ConstituentLibrary lib : libs)
//				if (lib != null && lib.maxLength() >= i)
//					for (Constituent c : lib.getMembersOfLength(i))
//						list.add(c);
//			
//			// Print set
//			for (Constituent c : list)
//			{
//				String result = c.toString() + "\t";
//				
//				System.out.print(result);
//				
//				
//				
//				for (ConstituentLibrary lib : libs)
//				{
//					double prob = 0;
//					if (lib != null && i <= lib.maxLength())
//						for (Constituent onset : lib.getMembersOfLength(i))
//							if (onset.sameSequence(c))
//							{
//								prob = onset.getProbability();
//								break;
//							}
//					
//					if (prob == 0)
//						System.out.print("    0\t");
//					else
//						System.out.printf("%.3f\t", prob);
//				}
//				
//				System.out.println();
//			}
//			System.out.println();
//		}
		System.out.println("Comparison not available at present.");
	}
	
	public void compareNuclei()
	{
		System.out.println("Comparison not available at present.");

//		for (int i = 1; i <= maxNucleusLength; i++)
//		{
//			ArrayList<Constituent> list = new ArrayList<Constituent>()
//			{	
//				public boolean add(Constituent c)
//				{
//					Iterator<Constituent> itr = this.iterator();
//					while (itr.hasNext())
//					{
//						Constituent next = itr.next();
//						if (c.sameSequence(next))
//							return false;
//					}
//					super.add(c);
//					return true;
//				}
//			};
//			
//			// Make combined set
//			ConstituentLibrary[] libs = new ConstituentLibrary[] { medialNuclei, initialNuclei, terminalNuclei,
//																	rootNuclei };
//			
//			for (ConstituentLibrary lib : libs)
//				if (lib != null && lib.maxLength() >= i)
//					for (Constituent c : lib.getMembersOfLength(i))
//						list.add(c);
//			
//			// Print set
//			for (Constituent c : list)
//			{
//				String result = c.toString() + "\t";
//				
//				System.out.print(result);
//				
//				
//				
//				for (ConstituentLibrary lib : libs)
//				{
//					double prob = 0;
//					if (lib != null && i <= lib.maxLength())
//						for (Constituent onset : lib.getMembersOfLength(i))
//							if (onset.sameSequence(c))
//							{
//								prob = onset.getProbability();
//								break;
//							}
//					
//					if (prob == 0)
//						System.out.print("    0\t");
//					else
//						System.out.printf("%.3f\t", prob);
//				}
//				
//				System.out.println();
//			}
//			System.out.println();
//		}
		
	}
	
	public boolean hasHiatus()
	{
		return true;
	}
	
	

	/**
	 * Sets the seed to the given value.
	 * @param 	newSeed		the value to which to set the seed
	 */
	public void setSeed(long newSeed)
	{
		rng.setSeed(newSeed);
	}
	
	/**
	 * Returns the original seed for the phonology's random number generator.
	 * @return	The Phonology's original seed
	 */
	public long getSeed()
	{
		return seed;
	}
	
		
	public ConstituentLibrary getMedialNuclei()
	{
		return medialNuclei;
	}
	
	public ConstituentLibrary getTerminalNuclei()
	{
		return terminalNuclei;
	}
	
	public ConstituentLibrary getRootNuclei()
	{
		return rootNuclei;
	}
	
	public void printClusters(ConstituentLibrary lib)
	{
		System.out.println("Clusters for library " + lib + ":");
		for (Constituent c : lib.getMembers())
		{
			printCluster(c, lib.getMaxClusterLength(), lib.getType(), 1, "");
		}
	}
	
	public void printCluster(Constituent c, int length, ConstituentType type, double baseProb, String stem)
	{
		System.out.println(stem + c.getContent() + "\t" + c.getProbability());
		if (length > 1)
			for (Constituent next : c.followers(type).getMembers())
				printCluster(next, length - 1, type, baseProb, stem + c.getContent());
			
		
	}
	
	public int getMaxOnsetLength() {
		return maxOnsetLength;
	}
	
	public int getMaxNucleusLength() {
		return maxNucleusLength;
	}
	
	public int getMaxCodaLength() {
		return maxCodaLength;
	}	
}
	
	
