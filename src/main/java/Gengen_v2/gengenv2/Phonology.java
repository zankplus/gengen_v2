/** Copyright 2018 Clayton Cooper
 *	
 *	This file is part of gengen2.
 *
 *	gengen2 is free software: you can redistribute it and/or modify
 *	it under the terms of the GNU General Public License as published by
 *	the Free Software Foundation, either version 3 of the License, or
 *	(at your option) any later version.
 *
 *	gengen2 is distributed in the hope that it will be useful,
 *	but WITHOUT ANY WARRANTY; without even the implied warranty of
 *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *	GNU General Public License for more details.
 *
 *	You should have received a copy of the GNU General Public License
 *	along with gengen2.  If not, see <http://www.gnu.org/licenses/>.
 * 
 */

package Gengen_v2.gengenv2;

import java.io.OutputStream;
import java.io.PrintStream;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Random;

import org.apache.commons.math3.distribution.LogNormalDistribution;


/**
 * An individual, complete Phonology, or language. Each Phonology contains its own set of sounds (phonemic inventory),
 * rules for assembling those sounds into syllables and words (phonotactics), rules for syllable weight and stress
 * (prosody), and a host of other assorted parameters that govern the shape these features take. All Phonologies
 * share the same system of representing sounds in letters (orthography), which is (mostly) intuitive and (mostly)
 * unambiguous. A Phonology uses these features to generate new names that are sound linguistically similar to each
 * other,  but distinct from those generated by other Phonologies.
 * 
 * @author	Clayton Cooper
 * @version	1.0
 * @since	1.0
 */
public class Phonology
{
	protected Random rng;
	private String name;
	private long seed;
	
	/*
	 * Auxiliary systems
	 * 
	 * These are other special systems used by the Phonology to aid in name-making, defined in their own classes.
	 * StressSystem represents the Phonology's rules for stress as well as rhythm and word length, and is used
	 * to create stress patterns. NameAssembly takes these stress patterns and uses the Phonology's phonemes
	 * and phonotactics to create names that follow the pattern.
	 */
	private StressSystem stressSystem;
	NameAssembly nameAssembly;
	
	/* Prominence values
	 * 
	 *  Through repeated use in variable names, "prominence" has become, for me, something of a technical term, denoting
	 *  a raw measure of how common a phonological unit (a phoneme, a phonetic property, a syllable segment) is.
	 *  The value of a prominence variable doesn't have any meaning on its own, but often the prominences of every
	 *  member in a class of segments are summed to determine the probability of that segment appearing.
	 *  
	 *  The first three arrays of prominences below are a little different: they are never used directly, but are rather 
	 *  combined to determine prominence values for segments. They represent the prevalence of different properties in 
	 *  the Phonology's phonemic inventory.
	 *  
	 *  The "lead" and "follow" prominences represent a phoneme's tendency to precede or follow other sounds within
	 *  a consonant cluster, diphthong, or interlude, and are used to determine how commonplace each such cluster is.
	 */
	double[] baseProminences;	// Prominence of each consonantal phonetic property in the Phonology, as applied to 
								// syllable onsets. This is the the basic value from which other consonantal prominences
								// are derived by disturbance.
	double[] codaProminences;	// Prominence of each consonantal property, as applied to syllable codas
	double[] vowelProminences;	// Prominence of each vocalic phonetic property
	
	double[] onsetClusterLeadProminences;
	double[] onsetClusterFollowProminences;
	double[] diphthongLeadProminences;
	double[] diphthongFollowProminences;
	double[] codaClusterLeadProminences;
	double[] codaClusterFollowProminences;
	double[] interludeLeadProminences;
	double[] interludeFollowProminences;
	
	/*
	 * Phoneme inventories
	 * 	
	 * Arrays containing of all the phonemes (potentially) in the Phonology. These are sorted into consonant and
	 * vowel inventories. Note that a phoneme appearing in one of these inventories may still be absent from the
	 * language in practice if its prominence is 0 in every context.
	 */
	Phoneme[] consonantInventory;	// List of CONSONANTS represented in this Phonology
	Phoneme[] vowelInventory;		// List of VOWELS represented in this Phonology
	
	/*
	 * Syllable segment inventories
	 * 
	 * Lists of arrays enumerating every onset, nucleus, and coda available in the language. Each array contains
	 * all possible syllable segments of a certain length according to the array's index: the 0th array contains
	 * single phonemes ('simple' segments), the 1th array contains complex segments formed of 2 phonemes, the
	 * 2nd of 3, and so forth. Syllable segments with non-positive prominence are pruned can never appear and so
	 * are pruned from these lists.
	 */
	protected ArrayList<SyllableSegment>[] onsets;
	protected ArrayList<SyllableSegment>[] nuclei;
	protected ArrayList<SyllableSegment>[] codas;	
	
	/*
	 * Syllable segment length limits
	 * 
	 *  Determine the maximum length a consonant cluster or diphthong may take. These values are generated in
	 *  makeBasicSyllableStructure() but may be reduced during generation if no clusters of sufficient length
	 *  are present in that language. This keeps methods from trying to pick a syllable segment from an empty
	 *  list if, say, a Phonology technically allows onset clusters of length 3 but doesn't actually have any. 
	 */
	protected int maxOnsetLength;
	protected int maxNucleusLength;
	protected int maxCodaLength;
	
	/*
	 * Coda prominence variables
	 * 
	 * codaProminenceOffset is a flat value subtracted from every coda prominence value to manage the richness
	 * of the coda inventory. codaDisturbance governs how greatly the base prominences are disturbed to produce
	 * the coda prominence values, AS A PERCENTAGE of the prominenceStdev. At 0, coda values are undisturbed 
	 * compared to the base values; at 1, they have essentially been rerolled from scratch.
	 */
	private double codaProminenceOffset;
	private double codaDisturbance;
	
	/*
	 * General cluster offsets
	 * 
	 * Inhibitor values are added to or subtracted from the prominence of consonant clusters or diphthongs to
	 * manage the diversity of such features in a Phonology. 
	 */
	private double onsetClusterOffset;
	private double diphthongOffset;
	private double codaClusterOffset;
	private double hiatusOffset;
	private double interludeOffset;

	/*
	 * Specific cluster offsets
	 * 
	 * These values are added to or subtracted from particular cluster prominences in specific circumstances to
	 * help restrict their prominence to (the author's personal sense of) a more natural pattern.
	 */
	double onsetNgOffset;			// reduces the chance of a onset 'ng'
	double onsetTlDlOffset; 			// reduces the chances of an onset 'tl' or 'dl'
	double nasalDissonanceOffset;	// reduces the prevalence of coda nasal-plosive clusters that disagree in articulation
	double unequalVoicingOffset;		// reduces the prevalence of interludes that disagree in voicing
	
	/*	
	 * Cluster length probabilities
	 * 
	 * If it has been determined that a consonant cluster should appear, these probability tables are consulted
	 * to determine its length. The ith entry indicates the odds that a cluster of length i+2 (min. 2) should be
	 * used. The probabilities depend on the length of the cluster (longer clusters are exponentially rarer) and
	 * on the number of available syllable segments of that length.
	 * 
	 * The simple___Probability variables function analogously, representing the chance of no cluster appearing
	 * in a position where either may be possible.
	 */
	protected double[] onsetClusterLengthProbabilities;
	protected double[] codaClusterLengthProbabilities;
	protected double simpleOnsetProbability;		// overall probability of having an onset cluster vs. a simple onset
	protected double simpleCodaProbability;		// overall probability of having a coda cluster vs. a simple coda
	
	/*
	 * Phonotactic properties
	 * 
	 * These values are used in the determining where in a syllable certain sounds may appear, which is the task
	 * of the various make____() methods. the ___CategoriesRepresented arrays track which phonetic categories
	 * are present in a language (this can't be done just by consulting their prominences as categories with 
	 * negative prominence may still be present), while the valid___Transitions arrays dictate the phonotactic
	 * categories of which different phonemes might follow each other within clusters.
	 */
	private boolean[] consonantCategoriesRepresented;
	private boolean[] vowelCategoriesRepresented;
	
	private boolean[][] validOnsetTransitions;
	private boolean[][] validNucleusTransitions;
	private boolean[][] validCodaTransitions;

	/*
	 * Base occurrence chances
	 * 
	 * These represent the base chances of various features of syllables occurring, before scaling by the number
	 * of entries available to that class of features. These are used in the Flowchart class to determine the
	 * probability of transitioning between nodes. 
	 * 
	 * Cluster chances represent the chance of a marginally more complex syllable segment occurring. In places
	 * where either a simple or complex segment may occur, these represent the chance of a cluster appearing at
	 * all (as usual, before scaling). Within onset/coda clusters, these affect the chance of a more complex
	 * cluster appearing, and so are factored into the calculation of the ___ClusterLengthProbabilities and 
	 * simple___Probability variables in the setClusterChances() method.
	 */
	protected double baseOnsetClusterChance;
	protected double baseCodaClusterChance;
	protected double baseDiphthongChance;
	
	protected double strongHeavyRimeChance;
	protected double strongLightRimeChance;
	protected double weakHeavyRimeChance;
	protected double weakLightRimeChance;
	protected double emptyInitialOnsetProminence;
	protected double baseMedialOnsetChance;
	protected double baseMedialCodaChance;
	protected double baseTerminalCodaChance;
	

	/*
	 * Generator properties
	 * 
	 * These static variables are properties of the generate itself and are used to determine the values of
	 * different features within a language that have a random component to them. Most of them represent the
	 * mean and standard deviation values for Gaussian random numbers.
	 */
	
	// Prominence means/stdevs
	static double prominenceStdev					= 0.60;
	static double vowelProminenceStdev 				= 0.50;
	static double emptyInitialOnsetProminenceMean   = 0.3;
	static double emptyInitialOnsetProminenceStdev  = 0.15;
	static double onsetClusterProminenceMean	 	= 0.1;
	static double onsetClusterProminenceStdev 		= 0.05;
	static double clusterLeadStdev    				= 0.50;
	static double clusterFollowStdev  				= 0.50;
	static double nucleusLeadStdev  				= 0.50;
	static double nucleusFollowStdev 				= 0.50;

	// Bounding values
	static double minimumOnsetClusterProminence		= 0.01; 
	static double minimumNucleusClusterProminence	= 0.01;
	static double minimumCodaClusterProminence		= 0.01;
	
	// Offset means/stdevs
	static double codaOffsetMean					= 0.4;
	static double codaOffsetStdev					= 0.4;
	static double onsetNgOffsetMean					= 2;
	static double onsetNgOffsetStdev				= 1;
	static double onsetTlDlOffsetMean				= 1;
	static double onsetTlDlOffsetStdev				= 0.5;
	static double nasalDissonanceOffsetMean			= 2;
	static double nasalDissonanceOffsetStdev		= 1;
	static double unequalVoicingOffsetMean			= 1.25;
	static double unequalVoicingOffsetStdev			= 0.5;
	static double hiatusOffsetStdev					= 0.15;
	static double interludeOffsetStdev				= 0.15;
	
	// Base occurence chance means/stdevs 
	static double strongHeavyRimeChanceMean			= 0.8;
	static double strongHeavyRimeChanceStdev		= 0.2;
	static double weakHeavyRimeChanceMean			= 0.3;
	static double weakHeavyRimeChanceStdev			= 0.15;
	static double baseCodaChanceMean				= -0.5;
	static double baseCodaChanceStdev				= 0.5;
	static double codaLocationBalanceMean			= 0.4;
	static double codaLocationBalanceStdev			= 0.33;
	static double baseOnsetChanceMean				= 0;
	static double baseOnsetChanceStdev				= 0.1;
	static double baseOnsetChanceOffset				= 0.8;
	
	/*
	 * Statistical data
	 * 
	 * Assorted information about the prevalence of different syllabic features in the current Phonology.
	 * The items named in the final ints are stored in the respective indices in counts[].
	 */
	public int[] counts = new int[11];

	// Indices of counts 
	static final int SIMPLE_ONSETS				=  0;
	static final int COMPLEX_ONSETS				=  1;
	static final int SIMPLE_NUCLEI				=  2;
	static final int COMPLEX_NUCLEI				=  3;
	static final int SIMPLE_CODAS				=  4;
	static final int COMPLEX_CODAS				=  5;
	static final int SIMPLE_NUCLEI_WITH_HIATUS	=  6;
	static final int COMPLEX_NUCLEI_WITH_HIATUS	=  7;
	static final int COMPOUND_INTERLUDES		=  8;
	static final int LIGHT_RIMES				=  9;
	static final int HEAVY_RIMES				= 10;
	
	/*
	 * This constructor creates a complete Phonology by invoking a series of methods, each of which generates
	 * some part of the Phonology. The order of operations is important, as some methods depend on information
	 * generated by previous methods, or delete information that other methods use.
	 * @since	1.0
	 */
	public Phonology()
	{
		rng = new Random();
		
		// Set and print seed
		long seed = rng.nextLong();		
//		seed = 4968672162774089494L;	// my favorite test language
//		seed = -2768999911612446463L;
		System.out.println("Seed: " + seed);
		rng.setSeed(seed);
		
		// Commence construction
		makeBasicSyllableStructure();
		determineProminence();
		selectSegments();
		
		// Populate inventories
		makeOnsets();
		makeNuclei();
		makeHiatus();
		
		if (maxCodaLength > 0)
		{
			makeCodas();
			makeInterludes();
		}
		
		// Gather statistical data 
		counts = gatherStatistics();
		
		// Set chances for clusters of each length
		setClusterChances();
		
		// Set base chances for use in the flowchart
		setBaseChances();		
		
		// Create stress system
		stressSystem = new StressSystem(rng.nextLong());
		
		// Create flowchart
		nameAssembly = new NameAssembly(this);
	}
	
	/**
	 * This method determines the maximum length for each syllable segment type: onset, nucleus, and coda. For each of
	 * these it also initializes the corresponding arrays in preparation to store all the syllable segments of the
	 * appropriate length, and also determines the base cluster/diphthong chances and offsets. 
	 * @since	1.0
	 */
//	@SuppressWarnings("unchecked")
	public void makeBasicSyllableStructure()
	{
		int roll;
		
		// Determine max length for each syllable segment type.
		roll = rng.nextInt(12);
		if (roll < 3)			
			maxOnsetLength = 1;	// 3/12
		else if (roll < 9)
			maxOnsetLength = 2;	// 6/12
		else if (roll < 11)
			maxOnsetLength = 3;	// 2/12
		else
			maxOnsetLength = 4;	// 1/12
		
		roll = rng.nextInt(4);
		if (roll < 1)
			maxNucleusLength = 1;
		else
			maxNucleusLength = 2;

		roll = rng.nextInt(8);
		if (roll < 1)
			maxCodaLength = maxOnsetLength + 1;	// 1/8
		else if (roll < 4)
			maxCodaLength = maxOnsetLength;		// 3/8
		else if (roll < 7)
			maxCodaLength = maxOnsetLength - 1;	// 3/8
		else
			maxCodaLength = maxOnsetLength - 2;	// 1/8
		maxCodaLength = Math.max(maxCodaLength, 0);
		
		// Initialize phonemic inventory array(s) for each syllable segment type.
		onsets = new ArrayList[maxOnsetLength];
		for (int i = 0; i < onsets.length; i++)
			onsets[i] = new ArrayList<SyllableSegment>();
		
		nuclei = new ArrayList[maxNucleusLength];
		for (int i = 0; i < nuclei.length; i++)
			nuclei[i] = new ArrayList<SyllableSegment>();
		
		codas = new ArrayList[maxCodaLength];
		for (int i = 0; i < codas.length; i++)
			codas[i] = new ArrayList<SyllableSegment>();
		
		
		// Determine cluster chances and cluster offsets
		if (maxOnsetLength > 0)
		{
			baseOnsetClusterChance = Math.max(rng.nextGaussian() * onsetClusterProminenceStdev + onsetClusterProminenceMean,
											  minimumOnsetClusterProminence);
			onsetClusterOffset = rng.nextGaussian() * 0.25 + 0.5;
		}

		if (maxNucleusLength > 1)
		{
			baseDiphthongChance = Math.max(rng.nextGaussian() * 0.05 + 0.15, minimumNucleusClusterProminence);
			diphthongOffset = rng.nextGaussian() * 0.25 + 0.5;
		}
		
		if (maxCodaLength > 0)
		{
			baseCodaClusterChance = Math.max(rng.nextGaussian() * 0.1 + 0.25, minimumCodaClusterProminence);
			codaClusterOffset = rng.nextGaussian() * 0.25 + 0.5;
		}
	}

	/**
	 * Determine which phonetic properties will be present in this language. Present languages receive 
	 * a random "prominence" value; absent values receive a value of 0. Any segment all of whose properties
	 * are present may feature in the language. This segment can be said to possess a combined prominence value 
	 * equal to the sum of its properties' prominence values' means; this represents, for now, the relative
	 * chance of it appearing at the start of an onset (consonants only).
	 * 
	 * Related clusterLeadProminence and clusterFollowProminence help determine how frequently a consonant will
	 * appear in a cluster preceeding or following (respectively) other phonemes.
	 * @since	1.0
	 */ 
	public void determineProminence()
	{
		baseProminences = new double[ConsonantProperty.values().length];	// likelihood to appear at start of word
		vowelProminences = new double[VowelProperty.values().length];
		codaProminences = new double[ConsonantProperty.values().length];
		
		// Set onset prominence values for consonant properties
		for (int i = 0; i < ConsonantProperty.values().length; i++)
			if (rng.nextDouble() < ConsonantProperty.values()[i].probability)	// properties failing this check receive 0 prominence
				baseProminences[i] = Math.max(rng.nextGaussian() * prominenceStdev + 1, 0.001);
		
		// Set prominence values for vowel properties
		for (int i = 0; i < VowelProperty.values().length; i++)
			if (rng.nextDouble() < VowelProperty.values()[i].probability)	// properties failing this check receive 0 prominence
				vowelProminences[i] = Math.max(rng.nextGaussian() * vowelProminenceStdev + 1, 0.001);
		
		/*
		 * Set coda prominence values for consonant properties. 
		 * Coda prominence values are generated by "disturbing" base prominence values, that is, by adding a 
		 * randomly generated Gaussian term, so they are influenced by onset values but not beholden
		 * to them. The magnitude of the Gaussian term is determined by codaDisturbance, representing the
		 * proportion of prominenceStdev by which to scale the deviation.
		 */
		if (maxCodaLength > 0)
		{
			// Coda disturbance is the square of a uniformly distributed random number between 0 and 1
			codaDisturbance = Math.pow(rng.nextDouble(), 2);
			
			// Coda inhibitor is a gaussian random number; the mean and stdev are engine parameters.
			codaProminenceOffset = rng.nextGaussian() * codaOffsetStdev + codaOffsetMean;
			codaProminenceOffset = Math.max(0, codaProminenceOffset);
			
			for (int i = 0; i < baseProminences.length; i++)
				if (baseProminences[i] > 0)
				{
					// Take the onset (general) prominence value as a base
					codaProminences[i] = baseProminences[i];
					
					// Disturb prominence
					codaProminences[i] += rng.nextGaussian() * prominenceStdev * codaDisturbance;
					
					// Offset prominence
					codaProminences[i] -= codaProminenceOffset;
				}
		}
		
		// Set onset cluster lead/follow prominences
		if (maxOnsetLength > 1)
		{
			onsetClusterLeadProminences   = new double[ConsonantProperty.values().length];
			onsetClusterFollowProminences = new double[ConsonantProperty.values().length];
			
			for (int i = 0; i < ConsonantProperty.values().length; i++)
				if (baseProminences[i] > 0)
				{
					onsetClusterLeadProminences[i]   = rng.nextGaussian() * clusterLeadStdev   + 1;
					onsetClusterFollowProminences[i] = rng.nextGaussian() * clusterFollowStdev + 1;
				}
		}

		// Set diphthong (nucleus cluster) lead/follow prominences
		if (maxNucleusLength > 1)
		{
			diphthongLeadProminences   = new double[VowelProperty.values().length];
			diphthongFollowProminences = new double[VowelProperty.values().length];
			
			for (int i = 0; i < VowelProperty.values().length; i++)
				if (vowelProminences[i] > 0)
				{
					diphthongLeadProminences[i]   = rng.nextGaussian() * nucleusLeadStdev   + 1;
					diphthongFollowProminences[i] = rng.nextGaussian() * nucleusFollowStdev + 1;
				}
		}
		
		// Set coda lead/follow prominences
		if (maxCodaLength > 1)
		{
			codaClusterLeadProminences   = new double[ConsonantProperty.values().length];
			codaClusterFollowProminences = new double[ConsonantProperty.values().length];
			
			for (int i = 0; i < ConsonantProperty.values().length; i++)
				if (baseProminences[i] > 0)
				{
					codaClusterLeadProminences[i]   = rng.nextGaussian() * clusterLeadStdev   + 1;
					codaClusterFollowProminences[i] = rng.nextGaussian() * clusterFollowStdev + 1;
				}
		}
		
		// Set interlude lead/follow prominences
		interludeLeadProminences =   new double[ConsonantProperty.values().length];
		interludeFollowProminences = new double[ConsonantProperty.values().length];
		
		for (int i = 0; i < ConsonantProperty.values().length; i++)
			if (baseProminences[i] > 0)
			{
				interludeLeadProminences[i]   = rng.nextGaussian() * clusterLeadStdev   + 1;
				interludeFollowProminences[i] = rng.nextGaussian() * clusterFollowStdev + 1;
			}
		
		// Set miscellaneous phonotactic offsets
		onsetNgOffset   	  = Math.max(rng.nextGaussian() * onsetNgOffsetStdev + onsetNgOffsetMean, 0);
		onsetTlDlOffset 	  = Math.max(rng.nextGaussian() * onsetTlDlOffsetStdev + onsetTlDlOffsetMean, 0);
		nasalDissonanceOffset = Math.max(rng.nextGaussian() * nasalDissonanceOffsetStdev + nasalDissonanceOffsetMean, 0);
		unequalVoicingOffset  = Math.max(rng.nextGaussian() * unequalVoicingOffsetStdev + unequalVoicingOffsetMean, 0);
	}
	
	/**
	 * Decide which segments will be present in the language. Any phoneme all of whose constituent phonetic categories
	 * are present (i.e., have positive prominence) should be added. The same procedure is performed twice: once for
	 * consonants and one for vowels.
	 * @since	1.0
	 */
	public void selectSegments()
	{
		ArrayList<Phoneme> inv = new ArrayList<Phoneme>();
		
		// Make easy reference to consonant segment array
		Consonant[] consonants = Consonant.segments;
		
		// Populate consonant inventory
		for (int i = 0; i < consonants.length; i++)
		{
			// Resolve to add the segment to the inventory by default.
			// If any of the segment's properties has 0 prominence (i.e., is absent from the language), immediately
			// decide not to add the segment.
			boolean add = true;
			
			for (int j = 0; j < consonants[i].properties.length; j++) 
				if (baseProminences[((ConsonantProperty) consonants[i].properties[j]).ordinal()] == 0)
				{
					add = false;
					j = consonants[i].properties.length;
				}
			
			if (add)
				inv.add(new Phoneme(consonants[i]));
		}
		
		consonantInventory = inv.toArray(new Phoneme[0]);
		
		// Mark phonotactic transition categories represented in this language's inventory
		consonantCategoriesRepresented = new boolean[Cluster.consonantCategories.size()];
		for (Phoneme p : inv)
			consonantCategoriesRepresented[p.segment.transitionCategory] = true;
		
		// Make easy reference to vowel segment array
		Vowel[] vowels = Vowel.segments;
		
		inv = new ArrayList<Phoneme>();
		
		// Populate vowel inventory in the same fashion as the consonant array
		for (int i = 0; i < vowels.length; i++)
		{
			boolean add = true;
			
			for (int j = 0; j < vowels[i].properties.length; j++)
				if (vowelProminences[((VowelProperty) vowels[i].properties[j]).ordinal()] == 0)
				{
					add = false;
					j = vowels[i].properties.length;
				}
			
			if (add)
				inv.add(new Phoneme(vowels[i]));
		}
		
		vowelInventory = inv.toArray(new Phoneme[inv.size()]);
		
		// Mark phonotactic transition categories represented in this language's inventory
		vowelCategoriesRepresented = new boolean[Cluster.vowelCategories.size()];
		for (Phoneme p : inv)
			vowelCategoriesRepresented[p.segment.transitionCategory] = true;
	}
	
	/**
	 * First, this method determines which transitions are possible between different phonotactic categories,
	 * and therefore which phoneme pairs might occur as a consonant cluster in this Phonology's onsets.
	 * Having decided this, the method invokes findAllOnsets() to populate the onset list.
	 * @since	1.0
	 */
	public void makeOnsets()
	{
		// transProb contains every combination of 2 phonotactic categories
		int[][] transProb = Cluster.onsetTransitions;
		validOnsetTransitions = new boolean[transProb.length][transProb[0].length];
		
		// Roll lead and follow probabilities for each phonotactic category
		double[] leadProbability = new double[transProb.length], followProbability = new double[transProb[0].length];
		for (int i = 0; i < leadProbability.length; i++)
			leadProbability[i] = rng.nextDouble();
		for (int i = 0; i < followProbability.length; i++)
			followProbability[i] = rng.nextDouble();
		
		
		/* Determine which transitions are possible between phonotactic categories.
		 * Every possible transition between categories has a chance of occurring, but those chances
		 * are not wholly independent from each other. Instead of rolling an independent random variable
		 * for each combination, we instead roll two for each category - one to indicate the chance of it
		 * leading in a cluster, the other the chance of following. These are both uniformly distributed
		 * random variables between 0 and 1. The roll for the inclusion of a given cluster is the product
		 * of the the first phoneme's leadProbability and the second's followProbability. The cdf for the
		 * the product of these two random variables is f(z) = z - z * log z.
		 */
		for (int i = 0; i < transProb.length; i++)
			if (consonantCategoriesRepresented[i])
				for (int j = 0; j < transProb[0].length; j++)
					if (consonantCategoriesRepresented[j])
					{
						// Chance of representation ~= f(.4 x 15^(commonness - 3))
						// 3 -> .559, 2 -> .069, 1 -> .007
						double p = 0.4 * Math.pow(15, transProb[i][j] - 3);
						
						if (leadProbability[i] * followProbability[j] < p)
							validOnsetTransitions[i][j] = true; 
					}
	
		// Determine all onsets of every permissible length
		findAllOnsets();

		// Remove any unused onsets
		for (ArrayList<SyllableSegment> list : onsets)
			for (int i = 0; i < list.size(); i++)
				if (list.get(i).probability < 0)
				{
					list.remove(i);
					i--;
				}
		
		// Shrink maxOnsetLength to hide lengths with empty arrays
		if (maxOnsetLength > 0)
			for ( ; onsets[maxOnsetLength - 1].size() == 0; maxOnsetLength--);
		
		// Normalize probabilities and sort each onset list according to them
		for (int i = 0; i < maxOnsetLength; i++)
		{
			double total = 0;
			for (SyllableSegment onset : onsets[i])
				if (onset.probability > 0)
					total += onset.probability;
			
			for (SyllableSegment onset : onsets[i])
				onset.probability = onset.probability / total;
			
			Collections.sort(onsets[i]);
			Collections.reverse(onsets[i]);
		}
	}
	
	/**
	 * First, this method determines which transitions are possible between different phonotactic categories,
	 * and therefore which phoneme pairs might occur as diphthongs in this Phonology. Having decided this, 
	 * the method invokes findAllNuclei() to populate the nucleus list.
	 * 
	 * The math motivating the selection of phonotactic category transitions is explained in makeOnsets() and
	 * will not be restated here.
	 * 
	 * @since	1.0
	 */
	public void makeNuclei()
	{
		int[][] transProb = Cluster.nucleusTransitions;
		validNucleusTransitions = new boolean[transProb.length][transProb[0].length];
		
		// Roll lead and follow probabilities for each phonotactic category
		double[] leadProbability = new double[transProb.length], followProbability = new double[transProb[0].length];
		for (int i = 0; i < leadProbability.length; i++)
			leadProbability[i] = rng.nextDouble();
		for (int i = 0; i < followProbability.length; i++)
			followProbability[i] = rng.nextDouble();
		
		// Determine which transitions are possible between phonotactic categories
		for (int i = 0; i < transProb.length; i++)
		{
			if (vowelCategoriesRepresented[i])
				for (int j = 0; j < transProb[0].length; j++)
					if (vowelCategoriesRepresented[j] && transProb[i][j] > 0)
					{
						// Chance of representation ~= f(.4 x 15^(commonness - 3))
						// 3 -> .559, 2 -> .069, 1 -> .007
						double p = 0.4 * Math.pow(15, transProb[i][j] - 3);
						
						if (leadProbability[i] * followProbability[j] < p)
							validNucleusTransitions[i][j] = true; 
					}
		}
		
		// Populate the nucleus inventory list with nuclei of every permissible length
		findAllNuclei();

		// Remove vowel lengthener from simple nuclei list.
		// TODO: (This section will be removed with the formal addition of vocalic gemination.)
		for (int i = 0; i < nuclei[0].size(); i++)
			if (nuclei[0].get(i).content[0].segment.expression.equals(":"))	
			{
				nuclei[0].remove(i);
				System.out.println("Removed lengthener from simple nuclei");
			}
		
		// Removed any unused nuclei
		for (ArrayList<SyllableSegment> list : nuclei)
			for (int i = 0; i < list.size(); i++)
				if (list.get(i).probability < 0)
				{
					list.remove(i);
					i--;
				}
		
		// Shrink maxNucleusLength to hide lengths with empty arrays 
		if  (maxNucleusLength > 0)
			for ( ; nuclei[maxNucleusLength - 1].size() == 0; maxNucleusLength--);
		
		// Normalize probabilities and sort each nucleus list according to them
		for (int i = 0; i < maxNucleusLength; i++)
		{
			double total = 0;
			for (SyllableSegment nucleus : nuclei[i])
				if (nucleus.probability > 0)
					total += nucleus.probability;
			
			for (SyllableSegment nucleus : nuclei[i])
				nucleus.probability = nucleus.probability / total;
			
			Collections.sort(nuclei[i]);
			Collections.reverse(nuclei[i]);
		}
	}

	/**
	 * First, this method determines which transitions are possible between different phonotactic categories,
	 * and therefore which phoneme pairs might occur as consonant clusters in this Phonology's codas. Having
	 * decided this, the method invokes findAllCodas() to populate the nucleus list.
	 * 
	 * The math motivating the selection of phonotactic category transitions is explained in makeOnsets() and
	 * will not be restated here.
	 * 
	 * @since	1.0
	 */
	public void makeCodas()
	{
		int[][] transProb = Cluster.codaTransitions;
		validCodaTransitions = new boolean[transProb.length][transProb[0].length];
		
		// Roll lead and follow probabilities for each phonotactic category
		double[] leadProbability = new double[transProb.length], followProbability = new double[transProb[0].length];
		for (int i = 0; i < leadProbability.length; i++)
			leadProbability[i] = rng.nextDouble();
		for (int i = 0; i < followProbability.length; i++)
			followProbability[i] = rng.nextDouble();

		// Determine which transitions are possible between phonotactic categories
		for (int i = 0; i < transProb.length; i++)
			if (consonantCategoriesRepresented[i])
				for (int j = 0; j < transProb[0].length; j++)
					if (consonantCategoriesRepresented[j] && transProb[i][j] > 0)
					{
						// Chance of representation ~= f(.4 x 15^(commonness - 3))
						// 3 -> .559, 2 -> .069, 1 -> .007
						double p = 0.4 * Math.pow(15, transProb[i][j] - 3);
						
						if (leadProbability[i] * followProbability[j] < p)
							validCodaTransitions[i][j] = true; 
					}
	
		// Populate the coda inventory list with codas of every permissible length
		findAllCodas();

		// Remove unused codas
		for (ArrayList<SyllableSegment> list : codas)
			for (int i = 0; i < list.size(); i++)
				if (list.get(i).probability < 0)
				{
					list.remove(i);
					i--;
				}
		
		// Note that unlike makeOnsets and makeNuclei, in makeCodas We delay the normalization of coda values until after
		// makeInterludes, as that method makes use of codas (in particular, that may be cut from the master list.
	}
	
	/**
	 * This method decides what vowel-vowel transitions are allowed in the case of an empty interlude. The process
	 * is analogous to that used by the makeOnsets/Nuclei/Codas methods, except that transitions occur directly
	 * between vowels instead of phonotactic categories, if a transition is found, it is immediately added to the
	 * leading vowel's interlude list.
	 */
	public void makeHiatus()
	{
		hiatusOffset = rng.nextGaussian() * hiatusOffsetStdev;
		
		int[][] transProb = Cluster.hiatusTransitions;

		// Roll lead and follow probabilities.
		// -1 to count ignores the 'lengthener' segment
		double[] leadProbability = new double[Vowel.count - 1], followProbability = new double[Vowel.count - 1];
		for (int i = 0; i < leadProbability.length; i++)
			leadProbability[i] = rng.nextDouble();
		for (int i = 0; i < followProbability.length; i++)
			followProbability[i] = rng.nextDouble();
		
		for (int i = 0; i < nuclei[0].size(); i++)
		{
			Phoneme p1 = nuclei[0].get(i).content[0];
			for (int j = 0; j < nuclei[0].size(); j++)
			{
				Phoneme p2 = nuclei[0].get(j).content[0];
				
				// Chance of representation ~= f(.3 x 4^(commonness - 3))
				// 3 -> .446, 2 -> .155, 1 -> .050
				double probability = 0.3 * Math.pow(4, transProb[p1.segment.id][p2.segment.id] - 3) + hiatusOffset;
				
				if (leadProbability[p1.segment.id] * followProbability[p2.segment.id] < probability)
					p1.addInterlude(nuclei[0].get(j));
			}
			
			// Normalize probabilities and sort the current vowel's interludes according to them
			p1.normalizeAndSortInterludes();
		}
	}
	
	/**
	 * This method determines which onsets may follow a coda. Again, the process is based on that of
	 * makeOnsets/Nuclei/Codas; though like these method it considers transitions between phonotactic
	 * categories, it operates on individual phonemes and adds connecting onsets directly to the coda's
	 * interlude list.  
	 */
	public void makeInterludes()
	{
		interludeOffset = rng.nextGaussian() * interludeOffsetStdev;
		
		int[][] transProb = Cluster.interludeTransitions;
		
		// Roll lead and follow probabilities for each phonotactic category
		double[] leadProbability   = new double[transProb.length],
				 followProbability = new double[transProb[0].length];
		for (int i = 0; i < leadProbability.length; i++)
			leadProbability[i] = rng.nextDouble();
		for (int i = 0; i < followProbability.length; i++)
			followProbability[i] = rng.nextDouble();
		
		// Generate lists of interlude transitions for phonemes
		for (int i = 0; i < codas[0].size(); i++)
		{
			Phoneme p1 = codas[0].get(i).content[0];
			for (int j = 0; j < onsets[0].size(); j++)
			{
				Phoneme p2 = onsets[0].get(j).content[0];
				
				if (p1 != p2)	// Gemination will be covered by a separate process (1.0)
				{
					// Chance of representation ~= f(.4 x 15^(commonness - 3))
					// 3 -> .559, 2 -> .069, 1 -> .007
					double probability = 0.4 * Math.pow(15, transProb[p1.segment.transitionCategory][p2.segment.transitionCategory] - 3)
											+ interludeOffset;
					
					if (leadProbability[p1.segment.transitionCategory] * followProbability[p2.segment.transitionCategory] < probability)
						p1.addInterlude(onsets[0].get(j));
				}
			}
			
			// Normalize probabilities and sort the current coda's interlude list according to them.
			p1.normalizeAndSortInterludes();
		}
		
		// TODO: Temporary feature: remove codas with no interludes.
		// In the future, we may want to include these phonemes in the terminal coda, but those will be
		// handled by a separate inventory.
		for (ArrayList<SyllableSegment> codaList : codas)
			for (int i = 0; i < codaList.size(); i++)
				if (codaList.get(i).lastPhoneme().interludes[0].isEmpty())
				{
					codaList.remove(i);
					i--;
				}
		
		// Scale each coda's prominence by the log of the number of its interludes
		for (ArrayList<SyllableSegment> codaList : codas)
			for (int i = 0; i < codaList.size(); i++)
				codaList.get(i).probability *= Math.log(codaList.get(i).lastPhoneme().interludes[0].size() + 1);
		
		// Shrink maxCodaLength to hide lengths with empty arrays
		if (maxCodaLength > 0)
			for ( ; maxCodaLength > 0 && codas[maxCodaLength - 1].size() == 0; maxCodaLength--);
		
		// Normalize coda prominence values and sort each coda list according to them
		for (int i = 0; i < maxCodaLength; i++)
		{
			double total = 0;
			for (SyllableSegment coda : codas[i])
				if (coda.probability > 0)
					total += coda.probability;
			
			for (SyllableSegment coda : codas[i])
				coda.probability = coda.probability / total;
			
			Collections.sort(codas[i]);
			Collections.reverse(codas[i]);
		}
	}
		
	/**
	 * Counts a number of linguistic features. This information is useful later for constructing the NameAssembly:
	 * nodes with more possibilities should be given greater weight, and in order to count those possibilities, we
	 * need to know the prevalence of different features in this Phonology. The types of features counted (as of
	 * 1.0) are simple and complex onsets, simple and complex nuclei, simple and complex codas, simple and complex
	 * nuclei with available hiatus transitions, compound interludes, and light and heavy rimes.
	 * 
	 * @return 	int[]	An array holding the tally for each feature counted in the current Phonology
	 * @since	1.0
	 */
	public int[] gatherStatistics()
	{
		int[] results = new int[11];
		
		// Count all simple and complex onsets
		results[SIMPLE_ONSETS] += onsets[0].size();
		for (int i = 1; i < onsets.length; i++)
			results[COMPLEX_ONSETS] += onsets[i].size();
		
		// Count all simple and complex nuclei, and separately count those with hiatus
		for (int i = 0; i < nuclei.length; i++)
		{
			if (i == 0)
				results[SIMPLE_NUCLEI] += nuclei[0].size();
			else
				results[COMPLEX_NUCLEI] += nuclei[i].size();
		
			for (SyllableSegment ss : nuclei[i])
				if (!ss.content[ss.content.length - 1].interludes[0].isEmpty())
					if (i == 0)
						results[SIMPLE_NUCLEI_WITH_HIATUS]++;
					else
						results[COMPLEX_NUCLEI_WITH_HIATUS]++;
		}
		
		// Count all simple and complex codas, and compound interludes
		for (int i = 0; i < codas.length; i++)
		{
			if (i == 0)
				results[SIMPLE_CODAS] += codas[i].size();
			else
				results[COMPLEX_CODAS] += codas[i].size();
			for (SyllableSegment ss : codas[i])
			{
				Phoneme last = ss.content[ss.content.length - 1];
				
				for (ArrayList interludeList : last.interludes)
					results[COMPOUND_INTERLUDES] += interludeList.size();
			}
		}
		
		// Count light and heavy rimes
		results[LIGHT_RIMES]  = results[SIMPLE_NUCLEI] * results[SIMPLE_ONSETS]
							  +	results[SIMPLE_NUCLEI_WITH_HIATUS];
		
		results[HEAVY_RIMES]  = results[SIMPLE_NUCLEI] * results[COMPLEX_ONSETS] 
							  + results[SIMPLE_NUCLEI] * (results[SIMPLE_CODAS] + results[COMPLEX_CODAS])
							  + results[COMPLEX_NUCLEI_WITH_HIATUS]
							  + results[COMPLEX_NUCLEI] * results[SIMPLE_ONSETS]
							  + results[COMPLEX_NUCLEI] * results[COMPLEX_ONSETS]
							  + results[COMPLEX_NUCLEI] * (results[SIMPLE_CODAS] + results[COMPLEX_CODAS]);
		
		return results;
	}

	/**
	 * Sets the onset/codaClusterLengthProbabilities and simpleOnset/CodaProbability fields. 
	 * @since	1.0
	 */
	public void setClusterChances()
	{
		onsetClusterLengthProbabilities = new double[maxOnsetLength - 1];
		codaClusterLengthProbabilities = new double[Math.max(maxCodaLength - 1, 0)];
		
		// Assign onset cluster chances
		// Set values for cluster probabilities
		double total = 0;
		for (int i = 0; i < maxOnsetLength - 1; i++)
		{
			onsetClusterLengthProbabilities[i] = Math.log(onsets[i+1].size() + 1);
			onsetClusterLengthProbabilities[i] *= Math.pow(baseOnsetClusterChance, i + 1);
			total += onsetClusterLengthProbabilities[i];
		}
		
		// Normalize
		for (int i = 0; i < maxOnsetLength - 1; i++)
			onsetClusterLengthProbabilities[i] /= total;
		
		// Probability of a simple onset follows the same formula but is stored in a separate field
		simpleOnsetProbability = Math.log(onsets[0].size() + 1);
		simpleOnsetProbability = simpleOnsetProbability / (simpleOnsetProbability + total);
		
		// Set values for cluster probabilities
		total = 0;
		for (int i = 0; i < maxCodaLength - 1; i++)
		{
			codaClusterLengthProbabilities[i] = Math.log(codas[i+1].size() + 1);
			codaClusterLengthProbabilities[i] *= Math.pow(baseCodaClusterChance, i + 1);
			total += codaClusterLengthProbabilities[i];
		}
		
		// Normalize
		for (int i = 0; i < maxCodaLength - 1; i++)
			codaClusterLengthProbabilities[i] /= total;
		
		// Probability of a simple coda follows the same formula but is stored in a separate field
		if (maxCodaLength > 0)
		{
			simpleCodaProbability = Math.log(codas[0].size() + 1);
			simpleCodaProbability = simpleCodaProbability / (simpleCodaProbability + total);
		}
		else
			simpleCodaProbability = 0;
		
		// Set interlude and hiatus chances
		for (SyllableSegment ss : nuclei[0])
			ss.content[0].setInterludeClusterChance();
		if (maxCodaLength > 0)
			for (SyllableSegment ss : codas[0])
				ss.content[0].setInterludeClusterChance();
	}
	
	/**
	 * Sets base chances for heavy/light rimes, medial onsets, and medial/terminal codas. These values are used
	 * in NameAssembly to determine the weights of transitions between nodes.
	 * 
	 * Note that some liberty is taken with the use of 'rime' in this program; here, rime is the series of syllable
	 * segments that determines syllable weight and it therefore, because weight determination is based on Latin rules,
	 * includes the onset of the following syllable.
	 * 
	 * @since	1.0
	 */
	public void setBaseChances()
	{
		// Chance of a name starting with a vowel
		emptyInitialOnsetProminence = Math.max(rng.nextGaussian() * emptyInitialOnsetProminenceStdev + emptyInitialOnsetProminenceMean, 0);
		
		// Determine the chances of finding light or heavy rimes in weak or strong syllables.
		// If the Phonology has no heavy rimes, then it must have light ones in all positions.
		if (counts[HEAVY_RIMES] == 0)
		{
			weakLightRimeChance = 1;
			strongLightRimeChance = 1;
			weakHeavyRimeChance = 0;
			strongHeavyRimeChance = 0;
		}
		else
		{
			// Strong syllables 
			strongHeavyRimeChance = rng.nextGaussian() * strongHeavyRimeChanceStdev + strongHeavyRimeChanceMean;
			strongHeavyRimeChance = Math.max(Math.min(strongHeavyRimeChance, 1), 0);
			strongLightRimeChance = (1 - strongHeavyRimeChance);
			
			double total = strongHeavyRimeChance + strongLightRimeChance;
			strongHeavyRimeChance /= total;
			strongLightRimeChance /= total;
			
			// 
			weakHeavyRimeChance = rng.nextGaussian() * weakHeavyRimeChanceStdev + weakHeavyRimeChanceMean;
			weakHeavyRimeChance = Math.max(Math.min(weakHeavyRimeChance, 1), 0);
			weakLightRimeChance = (1 - weakHeavyRimeChance);
			
			total = weakHeavyRimeChance + weakLightRimeChance;
			weakHeavyRimeChance /= total;
			weakLightRimeChance /= total;
		}
		
		double baseCodaChance, codaLocationBalance;
		LogNormalDistribution logNormal;
		
		// Base medial onset chance		
		logNormal = new LogNormalDistribution(baseOnsetChanceMean, baseOnsetChanceStdev);
		logNormal.reseedRandomGenerator(rng.nextLong());
		
		if (counts[SIMPLE_NUCLEI_WITH_HIATUS] > 0)
			baseMedialOnsetChance = 1 - (logNormal.sample() - baseOnsetChanceOffset);
		else
			baseMedialOnsetChance = 1;
		
		baseMedialOnsetChance = Math.max(Math.min(baseMedialOnsetChance, 1), 0);
		
		// Base medial and terminal coda chances
		if (maxCodaLength > 0)
		{
			baseCodaChance = logNormal.sample();
			logNormal = new LogNormalDistribution(baseCodaChanceMean, baseCodaChanceStdev);
			logNormal.reseedRandomGenerator(rng.nextLong());
		}
		else
			baseCodaChance = 0;
		
		codaLocationBalance = rng.nextGaussian() * codaLocationBalanceStdev + codaLocationBalanceMean;
		codaLocationBalance = Math.max(Math.min(codaLocationBalance, 1), 0);
		
		baseMedialCodaChance =   Math.max(Math.min(baseCodaChance * codaLocationBalance, 1), 0);
		baseTerminalCodaChance = Math.max(Math.min(baseCodaChance * (1 - codaLocationBalance), 1), 0);
	}
	
	/**
	 * Returns any onset from the inventory at random.
	 * 
	 * @return	SyllableSegment	A randomly selected onset of any length
	 * @since	1.0
	 */
	public SyllableSegment pickOnset()
	{
		if (maxOnsetLength == 1 || rng.nextDouble() < simpleOnsetProbability)
			return pickSimpleOnset();
		else
			return pickComplexOnset();
	}
	
	/**
	 * Returns a simple onset at random.
	 * 
	 * @return	SyllableSegment	A randomly selected onset of length 1
	 * @since	1.0
	 */
	public SyllableSegment pickSimpleOnset()
	{
		return pickSyllableSegment(onsets[0]);
	}
	
	/**
	 * Returns a complex onset at random, or null if the Phonology has no complex onsets.
	 * 
	 * @return	SyllableSegment	A randomly selected onset of length 2 or more, or null
	 * @since	1.0 
	 */
	public SyllableSegment pickComplexOnset()
	{
		if (maxOnsetLength > 1)
			return pickSyllableSegment(onsets[1 + pickClusterLength(onsetClusterLengthProbabilities)]);
		else
			return null;
	}
	
	/**
	 * Returns a simple nucleus at random.
	 * 
	 * @return	SyllableSegment	A randomly selected nucleus of length 1
	 * @since	1.0
	 */
	public SyllableSegment pickSimpleNucleus()
	{
		return pickSyllableSegment(nuclei[0]);
	}
	
	/**
	 * Returns a complex nucleus at random, or null if the Phonology has no complex nuclei.
	 * 
	 * @return	SyllableSegment	A randomly selected nucleus of length 2 or more, or null
	 * @since	1.0
	 */
	public SyllableSegment pickComplexNucleus()
	{
		if (maxNucleusLength > 1)
			return pickSyllableSegment(nuclei[1]);
		else
			return null;
	}
	
	/**
	 * Returns any coda from the inventory at random.
	 * 
	 * @return	SyllableSegment	A randomly selected coda of any length
	 * @since	1.0
	 */
	public SyllableSegment pickCoda()
	{
		if (maxCodaLength == 1 || rng.nextDouble() < simpleCodaProbability)
			return pickSimpleCoda();
		else
			return pickComplexCoda();
	}
	
	/**
	 * Returns a simple coda at random, or null if the language has no codas.
	 * 
	 * @return	SyllableSegment	A randomly selected coda of length 1, or null
	 * @since	1.0
	 */
	public SyllableSegment pickSimpleCoda()
	{
		if (maxCodaLength > 0)
			return pickSyllableSegment(codas[0]);
		else
			return null;
	}
	
	/**
	 * Returns a complex coda at random, or null if the Phonology has no complex codas.
	 * 
	 * @return	SyllableSegment	A randomly selected coda of length 2 or more, or null
	 * @since	1.0
	 */
	public SyllableSegment pickComplexCoda()
	{
		if (maxCodaLength > 1)
			return pickSyllableSegment(codas[1 + pickClusterLength(codaClusterLengthProbabilities)]);
		else
			return null;
	}
	
	/**
	 * Returns a syllable segment from a given phoneme's interlude list. For a coda, this segment represents the
	 * onset of the next syllable. For a nucleus, this segment represents the nucleus of the next syllable in
	 * a case of hiatus (no consonantal boundary between syllables).
	 * @param	p	The last phoneme of the current syllable, hence the final element of either a coda or nucleus
	 * @return	SyllableSegment	The first syllable segment of the next syllable, hence either an onset or nucleus 
	 */
	public SyllableSegment pickInterlude(Phoneme p)
	{
		if (maxOnsetLength == 1)
			return p.pickInterlude(0);
		else
		{
			return p.pickInterlude(pickClusterLength(p.interludeLengthProbabilities));
		}
	}
	
	/**
	 * General method for returning a random syllable segment from a given arraylist.
	 * 
	 * @param 	inventory	A list of syllable segments (onsets, nuclei, or codas) of a particular length, from the master inventory
	 * @return	SyllableSegment	One ite
	 * @since	1.0
	 */
	private SyllableSegment pickSyllableSegment(ArrayList<SyllableSegment> inventory)
	{
		// Generate a random number between 1 and 0 and subtract probability values in order (the  lists are sorted
		// largest to smallest) until we reach a number lower than 0. The syllable segment whose prominence value took 
		// us over the edge is returned.		
		try
		{
			double rand = rng.nextDouble();
			for (SyllableSegment ss : inventory)
			{
				if (rand < ss.probability)
					return ss;
				else
					rand -= ss.probability;
			}
			throw new Exception();
		} catch (Exception e) {
			System.err.println("Failed to select syllable segment; were the inventory's prominence values not normalized?");
			for (SyllableSegment ss : inventory)
				System.out.println(ss + " " + ss.probability);
			e.printStackTrace();
			System.exit(0);
		}
		
		return null;
	}
	
	/**
	 * Picks an index from an array of doubles (corresponding to a list of probabilities for clusters of different lengths).
	 * The sum of all entries in the array is assumed to equal one. The probability of an index being returned should therefore
	 * be equal to that index's value.
	 * 
	 * @param	probabilities	A list of cluster length probabilities (either for onset or coda)
	 * @return	int				The index corresponding to the length of cluster selected
	 * @since	1.0
	 */
	private int pickClusterLength(double[] probabilities)
	{
		// Select length of onset
		double rand = rng.nextDouble();
		for (int i = 0 ; i < probabilities.length; i++)
		{
			if (rand < probabilities[i])
				return i;
			else
				rand -= probabilities[i];
		}
		
		System.err.println("pickClusterLength() returned -1");
		System.exit(0);
		return -1;
	}
	
	/**
	 * Populates the onset inventories by calling the recursive function findAllOnsets(ArrayList<Phoneme>) for each
	 * phoneme on the consonant inventory.
	 * @since	1.0
	 */
	private void findAllOnsets()
	{
		for (Phoneme p : consonantInventory)
		{
			ArrayList<Phoneme> onset = new ArrayList<Phoneme>();
			onset.add(p);
			findAllOnsets(onset);
		}
	}
	
	/**
	 * Discovers every available onset beginning with the given phoneme sequence. This method starts by adding the current
	 * phoneme, then recurses on every onset that might be formed by adding one more phoneme to the current one.
	 * @param	onset	An onset of arbitrary length
	 * @since	1.0
	 */
	private void findAllOnsets(ArrayList<Phoneme> onset)
	{
		// Start by adding the current phoneme.
		// To do this, its prominence (unnormalized probability) must be calculated.
		// For simple onsets, the prominence is merely equal to its sole phoneme's onset initial prominence.
		double prominence = onset.get(0).onsetInitialProminence;

		// For complex onsets, the initial onset prominence of the first phoneme is combined with the
		// onset cluster lead/follow prominences for every consecutive pair of phonemes by adding their
		// deviations from their common mean. The onsetClusterOffset is also applied for each pair.
		if (onset.size() > 1)
			for (int i = 0; i < onset.size() - 1; i++)
			{
				prominence += onset.get(i).onsetClusterLeadProminence + onset.get(i+1).onsetClusterFollowProminence - 2  - onsetClusterOffset;
				
				// Offset for tl/dl clusters
				if (onset.get(i).segment.properties[0] == ConsonantProperty.PLOSIVE &&
					onset.get(i).segment.properties[1] == ConsonantProperty.ALVEOLAR &&
					onset.get(i+1).segment.expression.equals("l"))
				{
					prominence -= onsetTlDlOffset;
				}
			}
		
		// Add the current onset to the appropriate onset inventory
		SyllableSegment seg = new SyllableSegment(SegmentType.ONSET, onset.toArray(new Phoneme[onset.size()]), prominence);
		onsets[onset.size() - 1].add(seg);
		
		// If you've reached the largest cluster size, return immediately and do not examine large clusters
		if (onset.size() >= maxOnsetLength)
			return;
		
		// Otherwise, consider what additions to this cluster might be possible
		int ptCat = onset.get(onset.size() - 1).segment.transitionCategory; // get phonotactic transition category of the latest phoneme
		
		// For each phonotactic category to which the current phoneme might transition...
		for (int i = 0; i < validOnsetTransitions[ptCat].length; i++)
			if (validOnsetTransitions[ptCat][i])
			{
				// ... consider every member segment.
				for (int nextSound : Cluster.consonantCategories.get(i))
				{
					// If this Phonology has that segment, then create a new cluster by appending it to the current,
					// and recurse on it.
					for (int j = 0; j < consonantInventory.length; j++)
						if (consonantInventory[j].segment.id == nextSound)
						{
							ArrayList<Phoneme> copy = new ArrayList<Phoneme>();
							for (Phoneme p : onset)
								copy.add(p);
							copy.add(consonantInventory[j]);
							
							findAllOnsets(copy);
							j = consonantInventory.length;	// Segment found; stop searching
						}
				}
			}
	}
	
	/**
	 * Populates the nucleus inventories by calling the recursive function findAllNuclei(ArrayList<Phoneme>) on each
	 * phoneme in the vowel inventory.
	 * @since	1.0
	 */
	private void findAllNuclei()
	{
		for (Phoneme p : vowelInventory)
		{
			ArrayList<Phoneme> nucleus = new ArrayList<Phoneme>();
			nucleus.add(p);
			findAllNuclei(nucleus);
		}
	}
	
	/**
	 * Discovers every available nucleus beginning with the given phoneme sequence. This method starts by adding the current
	 * phoneme, then recurses on every nucleus that might be formed by adding one more phoneme to the current one.
	 * @param	nucleus	A nucleus of arbitrary length
	 * @since	1.0
	 */
	private void findAllNuclei(ArrayList<Phoneme> nucleus)
	{
		// Do not allow nuclei beginning with a vowel lengthener
		if (nucleus.get(0).segment.expression.equals(":"))
			return;
		
		// Start by adding the current phoneme.
		// To do this, its prominence (unnormalized probability) must be calculated.
		// For simple nuclei, the prominence is merely equal to its sole phoneme's onset initial prominence (we're talking
		// about nuclei here, but the variable does double duty).
		double prominence = nucleus.get(0).onsetInitialProminence;
		
		// For complex nuclei, the maximum length of which is 2, the initial onset prominence of the first phoneme is
		// combined with the diphtong lead and follow prominences for pair by adding their deviations from their common mean.
		// The onsetClusterOffset is also applied.
		if (nucleus.size() > 1)
			for (int i = 0; i < nucleus.size() - 1; i++)
				prominence += nucleus.get(i).nucleusLeadProminence + nucleus.get(i+1).nucleusFollowProminence - 2 - diphthongOffset;
		
		// Add this nucleus to the appropriate nucleus inventory
		SyllableSegment seg = new SyllableSegment(SegmentType.NUCLEUS, nucleus.toArray(new Phoneme[nucleus.size()]), prominence);
		nuclei[nucleus.size() - 1].add(seg);
		
		// If you've reached the largest nucleus length, return without examining any longer diphthongs
		if (nucleus.size() >= maxNucleusLength)
			return;
		
		// Otherwise, consider what additions to this diphthong might be possible
		int ptCat = nucleus.get(nucleus.size() - 1).segment.transitionCategory; // get phonotactic transition category of the latest phoneme
		
		// For each phonotactic category to which the current phoneme might transition...
		for (int i = 0; i < validNucleusTransitions[ptCat].length; i++)
			if (validNucleusTransitions[ptCat][i])
			{
				// ... consider every member segment.
				for (int nextSound : Cluster.vowelCategories.get(i))
				{
					// If this Phonology has that segment, then create a new cluster by appending it to the current,
					// and recurse on it.
					for (int j = 0; j < vowelInventory.length; j++)
						if (vowelInventory[j].segment.id == nextSound)
						{
							ArrayList<Phoneme> copy = new ArrayList<Phoneme>();
							for (Phoneme p : nucleus)
								copy.add(p);
							copy.add(vowelInventory[j]);
							
							findAllNuclei(copy);
							j = vowelInventory.length;	// Segment found; stop searching
						}
				}
			}
	}
	
	/**
	 * Populates the coda inventories by calling the recursive function findAllCodas(ArrayList<Phoneme>) for each
	 * phoneme in the consonant inventory.
	 * @since	1.0
	 */
	private void findAllCodas()
	{
		for (Phoneme p : consonantInventory)
		{
			ArrayList<Phoneme> coda = new ArrayList<Phoneme>();
			coda.add(p);
			findAllCodas(coda, Cluster.codaTransitions.length - 1);
		}
	}
	
	/**
	 * Discovers every available coda beginning with the given phoneme sequence. This method starts by adding the current
	 * phoneme, then recurses on every coda that might be formed by adding one more phoneme to the current one.
	 * @param	coda	A coda of arbitrary length
	 * @since	1.0
	 */
	private void findAllCodas(ArrayList<Phoneme> coda, int start)
	{
		// Do not allow codas beginning with a glide (this feature is covered by diphthongs)
		if (coda.get(0).segment.properties[0].equals(ConsonantProperty.GLIDE))
			return;

		// Start by adding the current phoneme.
		// To do this, its prominence (unnormalized probability) must be calculated.
		// For simple codas, the prominence is merely equal to its sole phoneme's codaInitialProminence.
		double prominence = coda.get(0).codaInitialProminence;
		
		// For complex codas, the initial coda prominence of the first phoneme is combined with the
		// coda cluster lead/follow prominences for every consecutive pair of phonemes by adding their
		// deviations from their common mean. The codaClusterOffset is also applied for each pair.
		if (coda.size() > 1)
			for (int i = 0; i < coda.size() - 1; i++)
			{
				prominence += coda.get(i).codaClusterLeadProminence + coda.get(i+1).codaClusterFollowProminence - 2 - codaClusterOffset;
				
				// Penalize for dissimilar nasal-plosive clusters
				if (isDissonantNasalCluster(coda.get(i), coda.get(i+1)))
					prominence -= nasalDissonanceOffset;
			}
		
		// Add the current coda to the appropriate coda inventory
		SyllableSegment seg = new SyllableSegment(SegmentType.CODA, coda.toArray(new Phoneme[coda.size()]), prominence);
		codas[coda.size() - 1].add(seg);
		
		// If you've reached the largest cluster size, return immediately and do not examine large clusters
		if (coda.size() >= maxCodaLength)
			return;
		
		// Otherwise, consider how this cluster might continue
		int ptCat = coda.get(coda.size() - 1).segment.transitionCategory; // get phonotactic transition category of the latest phoneme
		
		// For each phonotactic category to which the current phoneme might transition...
		for (int i = Math.floorMod(ptCat-1, validCodaTransitions.length); i != start; i = Math.floorMod(i-1, validCodaTransitions.length))
			if (validCodaTransitions[ptCat][i])
			{
				// ... consider every member segment.
				for (int nextSound : Cluster.consonantCategories.get(i))
				{
					// If this Phonology has that segment, then create a new cluster by appending it to the current,
					// and recurse on it.
					for (int j = 0; j < consonantInventory.length; j++)
						if (consonantInventory[j].segment.id == nextSound)
						{
							ArrayList<Phoneme> copy = new ArrayList<Phoneme>();
							for (Phoneme p : coda)
								copy.add(p);
							copy.add(consonantInventory[j]);
							
							findAllCodas(copy, start);
							j = consonantInventory.length;	// Segment found; stop searching		
						}
				}
			}
	}
	
	/**
	 * Generates a sample of Phonologies and compiles statistics on them. The function prints the average
	 * time taken to generate a phonology, as well as the average value for each feature tracked by gatherStatistics(). 
	 * @param	count	The number of Phonologies to generate for the sample 
	 * @since	1.0
	 */
	static protected void massGatherStats(int count)
	{
		// Initialize counts
		int[] persistentCounts = new int[11];

		// Start timer
		long startTime = System.nanoTime();
		
		// Suppress output by having System print to a dummy OutputStream
		PrintStream original = System.out;
		PrintStream dummy = new PrintStream(new OutputStream() { public void write(int b) {} });
		System.setOut(dummy);
		
		// Generate the given number of Phonologies and record their feature counts
		for (int i = 0; i < count; i++)
		{
			Phonology p = new Phonology();
			for (int j = 0; j < persistentCounts.length; j++)
				persistentCounts[j] += p.counts[j]; 
		}
		
		// Reset System.out to its original value
		System.setOut(original);
		
		// End timer
		long endTime = System.nanoTime();
		double time = (endTime - startTime) / (count * 1000000);
		
		// Print findings
		System.out.println("AVERAGE\tSIMPLE\tCOMPLEX");
		System.out.println("ONSETS\t" + (persistentCounts[SIMPLE_ONSETS] / count) + "\t" + (persistentCounts[COMPLEX_ONSETS] / count));
		System.out.println("NUCLEI\t" + (persistentCounts[SIMPLE_NUCLEI] / count) + "\t" + (persistentCounts[COMPLEX_NUCLEI] / count));
		System.out.println("CODAS \t" + (persistentCounts[SIMPLE_CODAS]  / count) + "\t" + (persistentCounts[COMPLEX_CODAS]  / count));
		System.out.println("HIATUS\t" + (persistentCounts[SIMPLE_NUCLEI_WITH_HIATUS]  / count) + "\t" 
									  + (persistentCounts[COMPLEX_NUCLEI_WITH_HIATUS]  / count));
		System.out.println("COMPOUND INTERLUDES\t" + persistentCounts[COMPOUND_INTERLUDES] / count);
		System.out.println("LIGHT RIMES\t" + persistentCounts[LIGHT_RIMES] / count);
		System.out.println("HEAVY RIMES\t" + persistentCounts[HEAVY_RIMES] / count);
		
		System.out.println("Average time per language: " + time + "ms");
	}
	
	/**
	 * Returns true if a nasal cluster has unharmonious voicing, i.e.,
	 * 1.  the first segment is a NASAL, and either
	 * 2a. the second segment is a plosive and its place of articulation differs from the first, OR
	 * 2b. the second segment is postalveolar and the first is not nasal
	 * @param	p1	The first segment
	 * @param	p2	The second segment
	 * @since	1.0
	 */
	private boolean isDissonantNasalCluster(Phoneme p1, Phoneme p2)
	{
		if (p1.segment.properties[0] == ConsonantProperty.NASAL &&
				((p2.segment.properties[0] == ConsonantProperty.PLOSIVE && p1.segment.properties[1] != p2.segment.properties[1]) || 
				 (p2.segment.properties[1] == ConsonantProperty.POSTALVEOLAR && p1.segment.properties[1] != ConsonantProperty.ALVEOLAR)))
			{
				return true;
			}
		
		return false;
	}
	
	/**
	 * Returns true if a cluster disagrees in voicing, i.e.,
	 * 1.  both segments are plosives, affricates, or fricatives, and either
	 * 2a. the first is voiced and the second is unvoiced, or
	 * 2b. vice versa
	 * @param	p1	The first segment
	 * @param	p2	The second segment
	 * @since	1.0
	 * */
	private boolean isUnequalVoicing(Phoneme p1, Phoneme p2)
	{
		SegmentProperty place1 = p1.segment.properties[0];
		SegmentProperty place2 = p2.segment.properties[0];
		SegmentProperty voice1 = p1.segment.properties[1];
		SegmentProperty voice2 = p2.segment.properties[1];
		
		if ((place1 == ConsonantProperty.PLOSIVE || place1 == ConsonantProperty.AFFRICATE || place1 == ConsonantProperty.FRICATIVE) &&
			(place2 == ConsonantProperty.PLOSIVE || place2 == ConsonantProperty.AFFRICATE || place2 == ConsonantProperty.FRICATIVE) &&
			(voice1 == ConsonantProperty.VOICED  || voice1 == ConsonantProperty.VOICELESS) &&
			(voice2 == ConsonantProperty.VOICED  || voice2 == ConsonantProperty.VOICELESS) &&
			(voice1 != voice2))
			{
				return true;
			}
		
		return false;
	}
	
	/**
	 * Returns this Phonology's stress system
	 * @return	This Phonology's stress system
	 * @since	1.0
	 */
	protected StressSystem getStressSystem()
	{
		return stressSystem;
	}
	
	/**
	 * Prints various data about the current Phonology in great depth, including the contents of inventories,
	 * the statistics of the Phonology's stress system, and the chances of light and heavy rimes in weak and
	 * strong positions.
	 * @since	1.0
	 */
	public void printPhonology()
	{
		// Print inventories
		for (int i = 0; i < maxOnsetLength; i++ )
			printInventory(onsets[i]);
		for (int i = 0; i < maxCodaLength; i++ )
			printInventory(codas[i]);
		for (int i = 0; i < maxNucleusLength; i++ )
			printInventory(nuclei[i]);

		// Print hiatus/interlude inventories
		System.out.println("Hiatus bonus: " +  hiatusOffset);
		printInterludes(nuclei[0]);
		if (codas.length > 0)
			printInterludes(codas[0]);
		
		// Print stress system
		System.out.println(stressSystem);
		
		// Print assorted base chances
		System.out.printf("strong:\tHeavy %.3f\n", strongHeavyRimeChance);
		System.out.printf("\t\tLight %.3f\n",  strongLightRimeChance);
		System.out.printf("weak:\tHeavy %.3f\n", weakHeavyRimeChance);
		System.out.printf("\t\tLight %.3f\n",  weakLightRimeChance);
	}
	
	/**
	 * Print every syllable segment in a given ArrayList
	 * @param	list	The list to be printed
	 * @since	1.0
	 */
	private void printInventory(ArrayList<SyllableSegment> list)
	{
		if (list.size() == 0)
			return;
	
		System.out.println(list.get(0).type + " " + list.get(0).content.length);
		for (SyllableSegment ss : list)
			System.out.printf("%s\t%.3f\n", ss, (ss.probability / 1));
		
		System.out.println();
	}
	
	/**
	 * Print the full list of interludes (or hiatus) for every segment in a given ArrayList
	 * @param	list	The list to be printed
	 * @since	1.0
	 */
	public void printInterludes(ArrayList<SyllableSegment> list)
	{
		if (list.size() == 0)
			return;
		
		for (SyllableSegment coda : list)
			coda.content[coda.content.length - 1].printInterludes();
	}

	/**
	 * A phoneme, or basic unit of sound. A Phoneme is an instance of a Segment specific to a given Phonology;
	 * the Segment determines what sound it makes, but the Phoneme includes its own rules for how that sound
	 * is used in the language. Accordingly, the Phoneme object includes numerous prominence values, as well
	 * as (if appropriate) an inventory of interludes available to that sound.
	 * @since	1.0
	 */
	class Phoneme
	{
		Segment segment;
		
		// Interlude properties
		ArrayList<Follower>[] interludes;	// for vowels, the interlude field serve to describe hiatus
		double[] interludeLengthProbabilities;
		
		// Prominences
		double onsetInitialProminence;
		double onsetClusterLeadProminence;
		double onsetClusterFollowProminence;
		double codaInitialProminence;
		double codaClusterLeadProminence;
		double codaClusterFollowProminence;
		double nucleusLeadProminence;
		double nucleusFollowProminence;
		double interludeLeadProminence;		
		double interludeFollowProminence;
		
		/**
		 * This constructor sets all the appropriate prominence values, according to whether the Phoneme
		 * is a consonant or a vowel.
		 * @param	segment	The phonetic segment that characterizes this phoneme
		 * @since	1.0 
		 */
		public Phoneme(Segment segment)
		{
			this.segment = segment;
			
			// Consonant case
			if (segment.isConsonant())
			{
				// Initialize interlute lists
				interludes = new ArrayList[maxOnsetLength];
				for (int i = 0; i < maxOnsetLength; i++)
					interludes[i] = new ArrayList<Follower>();
				
				// Assign default prominence values
				onsetInitialProminence       = 1;
				codaInitialProminence		 = 1;
				onsetClusterLeadProminence   = 1;
				onsetClusterFollowProminence = 1;
				codaClusterLeadProminence    = 1;
				codaClusterFollowProminence  = 1;
				interludeLeadProminence  	 = 1;
				interludeFollowProminence 	 = 1;
				
				// Apply offsets
				if (segment.expression.equals("ng"))
				{
					onsetInitialProminence    -= onsetNgOffset;
					interludeFollowProminence -= onsetNgOffset;
				}
				
//				if (segment.expression.equals("sh") || segment.expression.equals("zh"))
//				{
//					
//				}
				
				/* Calculate prominence values. 
				 * Math note: initialProminence is the result of combining all the prominence values of the
				 * segment's properties, with mean 1. The deviance of each prominence is scaled by the root of
				 * the number of the segment's properties; this ensures that all intialProminence values are
				 * distributed, in effect, with the same standard deviation, regardless of how many values are
				 * added to make it (normally, adding random variables increases the stdev of the sum). The
				 * same is true of the cluster prominence values as well.
				 */
				for (ConsonantProperty s : ((Consonant) segment).properties)
				{
					double deviance = baseProminences[s.ordinal()] - 1;
					deviance /= Math.sqrt(segment.properties.length);
					onsetInitialProminence += deviance;
					
					if (maxCodaLength > 0)
					{
						deviance = codaProminences[s.ordinal()] - 1;
						deviance /= Math.sqrt(segment.properties.length);
						codaInitialProminence += deviance;
					}
					
					// Onset cluster properties
					if (maxOnsetLength > 1)
					{
						deviance = onsetClusterLeadProminences[s.ordinal()] - 1;
						deviance /= Math.sqrt(segment.properties.length);
						onsetClusterLeadProminence += deviance;
						
						deviance = onsetClusterFollowProminences[s.ordinal()] - 1;
						deviance /= Math.sqrt(segment.properties.length);
						onsetClusterFollowProminence += deviance;
					}
					
					// Coda cluster properties
					if (maxCodaLength > 1)
					{
						deviance = codaClusterLeadProminences[s.ordinal()] - 1;
						deviance /= Math.sqrt(segment.properties.length);
						codaClusterLeadProminence += deviance;
						
						deviance = codaClusterFollowProminences[s.ordinal()] - 1;
						deviance /= Math.sqrt(segment.properties.length);
						codaClusterFollowProminence += deviance;
						
						deviance = interludeLeadProminences[s.ordinal()] - 1;
						deviance /= Math.sqrt(segment.properties.length);
						interludeLeadProminence += deviance;
						
						deviance = interludeFollowProminences[s.ordinal()] - 1;
						deviance /= Math.sqrt(segment.properties.length);
						interludeFollowProminence += deviance;
					}
				}
				
//				System.out.printf("%s\t%.3f\t%.3f\t%.3f\t%.3f\t%.3f\t%.3f\t%.3f\t%.3f\n", segment.expression,
//									onsetInitialProminence,  onsetClusterLeadProminence, onsetClusterFollowProminence,
//									codaInitialProminence,   codaClusterLeadProminence,  codaClusterFollowProminence,
//									interludeLeadProminence, interludeFollowProminence);
			}

			// Vowel case
			else
			{
				// Initialize interludes
				interludes = new ArrayList[maxNucleusLength];
				for (int i = 0; i < maxNucleusLength; i++)
					interludes[i] = new ArrayList<Follower>();

				// Assign initial prominence values
				onsetInitialProminence		= 1;	// this functions as the nucleus initial prominence here
				nucleusLeadProminence 		= 1;
				nucleusFollowProminence 	= 1;
				interludeLeadProminence  	= 1;
				interludeFollowProminence 	= 1;
				
				// Calculate prominence values
				for (VowelProperty s : ((Vowel) segment).properties)
				{
					double deviance = vowelProminences[s.ordinal()] - 1;
					deviance /= Math.sqrt(segment.properties.length);
					onsetInitialProminence += deviance;

					deviance = interludeLeadProminences[s.ordinal()] - 1;
					deviance /= Math.sqrt(segment.properties.length);
					interludeLeadProminence += deviance;
					
					deviance = interludeFollowProminences[s.ordinal()] - 1;
					deviance /= Math.sqrt(segment.properties.length);
					interludeFollowProminence += deviance;
					
					if (maxNucleusLength > 1)
					{
						deviance = diphthongLeadProminences[s.ordinal()] - 1;
						deviance /= Math.sqrt(segment.properties.length);
						nucleusLeadProminence += deviance;
						
						deviance = diphthongFollowProminences[s.ordinal()] - 1;
						deviance /= Math.sqrt(segment.properties.length);
						nucleusFollowProminence += deviance;	
					}
					else
					{
						nucleusLeadProminence = 0;
						nucleusFollowProminence = 0;
					}
				}
				
//				System.out.printf("%s\t%.3f\t%.3f\t%.3f\n", segment.expression, onsetInitialProminence, nucleusLeadProminence, nucleusFollowProminence);
			}
		}
		
		/**
		 * Adds a SyllableSegment to this Phoneme's interlude inventory. If this Phoneme represents a consonant,
		 * the SyllableSegment represents an onset that may follow when this Phoneme is used as a coda. If this
		 * Phoneme represents a vowel, the SyllableSegment represents a nucleus that may follow in hiatus.
		 * @param	ss	A coda or nucleus that may follow this Phoneme
		 * @since	1.0
		 */
		protected void addInterlude(SyllableSegment ss)
		{
			// If interludeLeadProminence <= 0, this phoneme does not lead in interludes/hiatus
			if (interludeLeadProminence <= 0)
				return;
			
			// Calculate interlude's probability.
			// Base probability equals sum of following segment's interludeFollow and onsetInitial prominences
			double probability = ss.content[0].interludeFollowProminence + ss.content[0].onsetInitialProminence - 1;
			
			// Apply nasal dissonance inhibitor, if relevant
			if (segment.isConsonant() && isDissonantNasalCluster(this, ss.content[0]))
				probability -= nasalDissonanceOffset;
			
			// If probability is positive, add this interlude
			if (probability > 0)
				interludes[0].add(new Follower(ss, probability));
			
			// Add any possible clusters, too. Examine onset clusters if this is a consonantal interlude ...
			if (segment.isConsonant())
				for (int i = 1; i < maxOnsetLength; i++)
				{
					for (SyllableSegment onset : onsets[i])
						if (onset.content[0] == ss.content[0])
						{
							// Set base probability equal to the next segment's prominence
							probability = onset.probability;
							
							// Apply offsets, if relevant
							if (isDissonantNasalCluster(this, onset.content[0]))
								probability -= nasalDissonanceOffset;
							
							if (isUnequalVoicing(this, onset.content[0]))
								probability -= unequalVoicingOffset;
							
							// If probability is positive, add this interlude
							if (probability > 0)
								interludes[i].add(new Follower(onset, probability));
						}
				}
			// ... or, if this is a hiatus, look at diphthongs
			else if (maxNucleusLength == 2)
				for (SyllableSegment diphthong : nuclei[1])
					if (diphthong.content[0] == ss.content[0])
					{
						// Set base probability equal to the next segment's prominence
						probability = diphthong.probability;
						
						// If probability is positive, add this interlude
						if (probability > 0)
							interludes[1].add(new Follower(diphthong, probability));
					}
			
//			Print interlude statistics
//			System.out.printf("%.3f (%.3f + %,3f)", probability, p.interludeFollowProminence, p.onsetInitialProminence);
		}
		
		/**
		 * When an onset is added to a name following a coda, or a nucleus after another nucleus, the first thing
		 * decided is that syllable segment's length, which is determined at random, with each length having its
		 * own probability based on the number of segments available of that length, and the base onset cluster/
		 * diphthong chance. This method determines those probabilities.
		 * @since	1.0  
		 */
		protected void setInterludeClusterChance()
		{
			// Obtain true length of longest followers allowed
			int maxFollowerLength = interludes.length;
			for ( ; maxFollowerLength > 0 && interludes[maxFollowerLength - 1].size() == 0; maxFollowerLength--);

			if (maxFollowerLength == 0)
				return;
			
			// Grab the base onset cluster/diphthong chance.
			// Each probability is scaled by this value raised to the power of the length minus 1.
			double baseClusterChance;
			if (segment.isConsonant())
				baseClusterChance = baseOnsetClusterChance;
			else
				baseClusterChance = baseDiphthongChance;
			
			// Unlike the general onset/nucleus/coda inventories, these probabilities include the chance of
			// a result of length 1.
			interludeLengthProbabilities = new double[maxFollowerLength];
			
			// If the longest follower allowed is length 1, it is the only length allowed. Set its probability to 1.
			// Otherwise, calculate the probability for each length.
			if (maxFollowerLength == 1)
				interludeLengthProbabilities[0] = 1;
			else
			{
				// Set values for cluster probabilities
				double total = 0;
				for (int i = 0; i < maxFollowerLength - 1; i++)
				{
					interludeLengthProbabilities[i] = Math.log(interludes[i].size() + 1);
					interludeLengthProbabilities[i] *= Math.pow(baseClusterChance, i);
					total += interludeLengthProbabilities[i];
				}
				
				// Normalize
				for (int i = 0; i < maxFollowerLength - 1; i++)
					interludeLengthProbabilities[i] /= total;
			}
		}
		
		/**
		 * Returns a random interlude of the given length. If no interlude exists of that length, an error is thrown
		 * and the program exits. Thus, this method should only be called package-internally and in circumstances in
		 * which it is certain that interludes are available for the given length. 
		 * @param	length	The length of following onset/nucleus to be selected
		 * @return	The selected onset/nucleus
		 * @since	1.0
		 */
		public SyllableSegment pickInterlude(int length)
		{
			double rand = rng.nextDouble();
			for (Follower f : interludes[length])
			{
				if (rand < f.probability)
					return f.ss;
				else
					rand -= f.probability;
			}
			
			System.err.println("Failed to select follower of length " + (length + 1) + " for phoneme " + this.segment.expression + "!");
			for (int i = 0; i < interludes[length].size(); i++)
				System.out.println(interludes[length].get(i));
			
			try
			{
				throw new Exception();
			} catch (Exception e)
			{
				e.printStackTrace();
			}
			
			System.exit(0);
			
			return null;
		}
		
		/**
		 * Normalizes the probabilities of all interludes to ensure they are fit for usage, then sorts them
		 * in descending order.
		 * @since	1.0
		 */
		public void normalizeAndSortInterludes()
		{
			for (ArrayList<Follower> interludeSet : interludes)
			{
				double total = 0;
				
				for (Follower f : interludeSet)
					total += f.probability;
				
				for (Follower f : interludeSet)
					f.probability = f.probability /= total;
				
				Collections.sort(interludeSet);
				Collections.reverse(interludeSet);
			}
		}
		
		/**
		 * Prints all followers available for this phoneme, along with their probabilities.
		 * @since	1.0
		 */
		public void printInterludes()
		{
			System.out.println("~~~" + segment.expression + "~~~");
			
			if (interludes[0].size() == 0)
				System.out.println("none");
			else
			{
				for (int i = 0; i < interludes.length; i++)
				{
					if (!interludes[i].isEmpty())
					{
						System.out.printf("[%.3f]\t", interludeLengthProbabilities[i]);
						for (Follower first : interludes[i])
							System.out.printf("%s%s (%.3f)\t", segment.expression, first.ss, first.probability);
						System.out.println();						
					}
				}
			}
		}
		
		/**
		 * A sortable syllable segment, paired with a probability value representing its prevalence specifically
		 * following the current phoneme across syllable boundaries. It represents either an onset following
		 * a coda, or a nucleus following another nucleus.
		 * @since	1.0
		 */
		class Follower implements Comparable<Follower>
		{
			SyllableSegment ss;
			double probability;
			
			public Follower(SyllableSegment ss, double probability)
			{
				this.ss = ss;
				this.probability = probability;
			}
			
			public int compareTo(Follower f)
			{
				if (probability > f.probability)
					return 1;
				else if (probability < f.probability)
					return -1;
				return 0;
			}
		}
	}

	/**
	 * Represents a sequence of 1 or more consecutive Phonemes in a particular position in a word -
	 * either an onset, a nucleus, or a coda.
	 * @since	1.0
	 */
	class SyllableSegment implements Comparable<SyllableSegment>
	{
		SegmentType type;
		Phoneme[] content;
		double probability;
		
		/**
		 * Constructor sets the syllable segment's essential parameters.
		 * @param	type		Syllable segment's type (onset, nucleus, coda)
		 * @param	content		Sequence of Phonemes comprising the segment
		 * @param	probability	Probability of this segment appearing out of all syllable segments of same type and length
		 * @since	1.0
		 */
		public SyllableSegment (SegmentType type, Phoneme[] content, double probability)
		{
			this.type = type;
			this.content = content;
			this.probability = probability;
		}
		
		/**
		 * Copy constructor.
		 * @param	other	Syllable segment to be copied
		 * @since	1.0
		 */
		public SyllableSegment(SyllableSegment other)
		{
			this.type = other.type;
			this.content = other.content;
			this.probability = other.probability;
		}
		
		/**
		 * Returns the last Phoneme in the syllable segment.
		 * @return	The last Phoneme in this segment's sequence of Phonemes.
		 * @since	1.0
		 */
		public Phoneme lastPhoneme()
		{
			return content[content.length - 1];
		}
		
		/**
		 * Returns a string containing the segment's constituent Phonemes in sequence.
		 * @return	The content of the syllable segment, in string form
		 * @since	1.0 
		 */
		public String toString()
		{
			String result = "";
			for (Phoneme p : content)
				result += p.segment.expression;
			return result;
		}

		/**
		 * Compares this segment's probability to another segment's; returns 1 if this segment's probability is higher,
		 * -1 if it is lower, and 0 if they are equal.
		 * @return	An int representing the relationship between this segment's probability and that of another segment
		 * @since	1.0
		 */
		public int compareTo(SyllableSegment ss)
		{
			if (probability > ss.probability)
				return 1;
			else if (probability < ss.probability)
				return -1;
			return 0;
		}
	}
}

enum SegmentType { ONSET, NUCLEUS, CODA; }